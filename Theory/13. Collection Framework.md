# ğŸ“š ì»¬ë ‰ì…˜ í”„ë ˆì„ì›Œí¬

## 1. ì»¬ë ‰ì…˜ í”„ë ˆì„ì›Œí¬ ê°œìš” ğŸ¯

### 1.1 ê¸°ë³¸ ê°œë…

- **ì •ì˜**: ë°ì´í„° ê·¸ë£¹ì„ ì €ì¥í•˜ê³  ì²˜ë¦¬í•˜ê¸° ìœ„í•œ í‘œì¤€í™”ëœ êµ¬ì¡°
- **íŒ¨í‚¤ì§€**: java.util
- **ì£¼ìš” êµ¬ì„±**:
    - Collection ì¸í„°í˜ì´ìŠ¤
    - List, Set, Map ì¸í„°í˜ì´ìŠ¤
    - êµ¬í˜„ í´ë˜ìŠ¤ë“¤

### 1.2 ì£¼ìš” ì¸í„°í˜ì´ìŠ¤ ê³„ì¸µ êµ¬ì¡° ğŸŒ³

```
Collection
â”œâ”€â”€ List (ìˆœì„œ O, ì¤‘ë³µ O)
â”œâ”€â”€ Set (ìˆœì„œ X, ì¤‘ë³µ X)
â”‚   â””â”€â”€ SortedSet
â”‚       â””â”€â”€ NavigableSet
â””â”€â”€ Queue (FIFO)
    â””â”€â”€ Deque (ì–‘ë°©í–¥)

Map (í‚¤-ê°’ ìŒ)
â””â”€â”€ SortedMap
    â””â”€â”€ NavigableMap

```

### 1.3 ì‚¬ìš© ëª©ì  ğŸ¯

- âœ¨ ë°ì´í„°ì˜ íš¨ìœ¨ì ì¸ ì €ì¥ê³¼ ê²€ìƒ‰
- ğŸ”„ ë°ì´í„° êµ¬ì¡°ì˜ ì¬ì‚¬ìš©ì„± í–¥ìƒ
- ğŸš€ í‘œì¤€í™”ëœ ì¸í„°í˜ì´ìŠ¤ë¡œ ìƒí˜¸ìš´ìš©ì„± í™•ë³´
- ğŸ’¡ ì•Œê³ ë¦¬ì¦˜ì˜ ì¬ì‚¬ìš©ì„ í†µí•œ ìƒì‚°ì„± í–¥ìƒ

## 2. List ì»¬ë ‰ì…˜ ğŸ“

### 2.1 ArrayList

### íŠ¹ì§• âœ¨

- ë™ì  ë°°ì—´ ê¸°ë°˜ êµ¬í˜„
- ìˆœì°¨ì  ì ‘ê·¼ ìµœì í™”
- ì„ì˜ ì ‘ê·¼ O(1)
- ì¤‘ê°„ ì‚½ì…/ì‚­ì œ O(n)

### ì½”ë“œ ì˜ˆì œ ğŸ’»

```java
// ì´ˆê¸° ìš©ëŸ‰ ì„¤ì •
List<String> list = new ArrayList<>(1000);

// ê¸°ë³¸ ì—°ì‚°
list.add("A");                // ì¶”ê°€
list.get(0);                  // ì¡°íšŒ
list.remove(0);              // ì‚­ì œ
list.set(0, "B");            // ìˆ˜ì •

// ë²Œí¬ ì—°ì‚°
list.addAll(Arrays.asList("A", "B", "C"));
list.removeIf(s -> s.isEmpty());

```

### ì„±ëŠ¥ ìµœì í™” íŒ ğŸ’¡

```java
// ìš©ëŸ‰ ìµœì í™”
list.trimToSize();

// ë¯¸ë¦¬ ìš©ëŸ‰ í™•ë³´
list.ensureCapacity(1000);

```

### 2.2 LinkedList

### íŠ¹ì§• âœ¨

- ì–‘ë°©í–¥ ì—°ê²° ë¦¬ìŠ¤íŠ¸
- ì‚½ì…/ì‚­ì œ O(1)
- ì„ì˜ ì ‘ê·¼ O(n)
- Deque ì¸í„°í˜ì´ìŠ¤ êµ¬í˜„

### ì½”ë“œ ì˜ˆì œ ğŸ’»

```java
LinkedList<String> linkedList = new LinkedList<>();
linkedList.addFirst("First");   // ì•ì— ì¶”ê°€
linkedList.addLast("Last");     // ë’¤ì— ì¶”ê°€
linkedList.removeFirst();       // ì•ì—ì„œ ì œê±°
linkedList.removeLast();        // ë’¤ì—ì„œ ì œê±°

```

## 3. Set ì»¬ë ‰ì…˜ ğŸ¯

### 3.1 HashSet

### íŠ¹ì§• âœ¨

- í•´ì‹œí…Œì´ë¸” ê¸°ë°˜
- ì¤‘ë³µ ë¶ˆê°€
- ìˆœì„œ ë³´ì¥ ì—†ìŒ
- null í—ˆìš©

### ì½”ë“œ ì˜ˆì œ ğŸ’»

```java
Set<String> set = new HashSet<>();
set.add("A");
set.add("B");
set.add("A");  // ì¤‘ë³µ ë¬´ì‹œ

```

### 3.2 TreeSet

### íŠ¹ì§• âœ¨

- ë ˆë“œ-ë¸”ë™ íŠ¸ë¦¬ ê¸°ë°˜
- ì •ë ¬ëœ ìƒíƒœ ìœ ì§€
- ë²”ìœ„ ê²€ìƒ‰ íš¨ìœ¨ì 
- null ë¶ˆê°€

### ì½”ë“œ ì˜ˆì œ ğŸ’»

```java
TreeSet<Integer> treeSet = new TreeSet<>();
treeSet.add(3);
treeSet.add(1);
treeSet.add(2);

// ë²”ìœ„ ê²€ìƒ‰
treeSet.subSet(1, 3);      // [1, 2]
treeSet.headSet(2);        // [1]
treeSet.tailSet(2);        // [2, 3]

```

## 4. Map ì»¬ë ‰ì…˜ ğŸ—ºï¸

### 4.1 HashMap

### íŠ¹ì§• âœ¨

- í•´ì‹œí…Œì´ë¸” ê¸°ë°˜
- í‚¤-ê°’ ìŒ ì €ì¥
- í‚¤ ì¤‘ë³µ ë¶ˆê°€
- null í‚¤/ê°’ í—ˆìš©

### ì½”ë“œ ì˜ˆì œ ğŸ’»

```java
Map<String, Integer> map = new HashMap<>();
map.put("A", 1);
map.put("B", 2);

// JDK 8 ì´ìƒì˜ ìƒˆë¡œìš´ ë©”ì„œë“œë“¤
map.computeIfAbsent("C", k -> k.length());
map.merge("A", 1, Integer::sum);

```

### 4.2 TreeMap

### íŠ¹ì§• âœ¨

- ë ˆë“œ-ë¸”ë™ íŠ¸ë¦¬ ê¸°ë°˜
- í‚¤ ê¸°ì¤€ ì •ë ¬
- ë²”ìœ„ ê²€ìƒ‰ íš¨ìœ¨ì 
- null í‚¤ ë¶ˆê°€

### ì½”ë“œ ì˜ˆì œ ğŸ’»

```java
TreeMap<String, Integer> treeMap = new TreeMap<>();
treeMap.put("A", 1);
treeMap.put("B", 2);
treeMap.put("C", 3);

// ë²”ìœ„ ê²€ìƒ‰
Map<String, Integer> subMap = treeMap.subMap("A", "C");

```

## 5. íŠ¹ìˆ˜ ëª©ì  ì»¬ë ‰ì…˜ ğŸ”§

### 5.1 ë™ê¸°í™”ëœ ì»¬ë ‰ì…˜

### íŠ¹ì§• âœ¨

- ìŠ¤ë ˆë“œ ì•ˆì „
- ë™ì‹œ ì ‘ê·¼ ì œì–´
- ì„±ëŠ¥ ì˜¤ë²„í—¤ë“œ ì¡´ì¬

### ì½”ë“œ ì˜ˆì œ ğŸ’»

```java
// ë™ê¸°í™”ëœ ì»¬ë ‰ì…˜ ìƒì„±
List<String> syncList = Collections.synchronizedList(new ArrayList<>());
Set<String> syncSet = Collections.synchronizedSet(new HashSet<>());
Map<String, String> syncMap = Collections.synchronizedMap(new HashMap<>());

```

### 5.2 ë¶ˆë³€ ì»¬ë ‰ì…˜

### íŠ¹ì§• âœ¨

- ìˆ˜ì • ë¶ˆê°€
- ìŠ¤ë ˆë“œ ì•ˆì „
- ë©”ëª¨ë¦¬ íš¨ìœ¨ì 

### ì½”ë“œ ì˜ˆì œ ğŸ’»

```java
// ë¶ˆë³€ ì»¬ë ‰ì…˜ ìƒì„±
List<String> immutableList = List.of("A", "B", "C");
Set<Integer> immutableSet = Set.of(1, 2, 3);
Map<String, Integer> immutableMap = Map.of("A", 1, "B", 2);

```

## 6. ì„±ëŠ¥ ìµœì í™” ë° ì£¼ì˜ì‚¬í•­ âš¡

### 6.1 ì„±ëŠ¥ ìµœì í™”

- ğŸ¯ ì ì ˆí•œ ì´ˆê¸° ìš©ëŸ‰ ì„¤ì •
- ğŸ”„ ë²Œí¬ ì—°ì‚° í™œìš©
- ğŸ’¾ ë©”ëª¨ë¦¬ ê´€ë¦¬
- ğŸš€ ì ì ˆí•œ ìë£Œêµ¬ì¡° ì„ íƒ

### 6.2 ì£¼ì˜ì‚¬í•­

- âš ï¸ ë™ì‹œì„± ê³ ë ¤
- ğŸ”’ ìŠ¤ë ˆë“œ ì•ˆì „ì„± í™•ë³´
- ğŸ—‘ï¸ ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ ë°©ì§€
- ğŸ“Š ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§

## 7. ì‹¤ì „ ì‘ìš© ì˜ˆì œ ğŸ’¡

### 7.1 LRU ìºì‹œ êµ¬í˜„

```java
public class LRUCache<K, V> {
    private final LinkedHashMap<K, V> cache;
    private final int capacity;

    public LRUCache(int capacity) {
        this.capacity = capacity;
        this.cache = new LinkedHashMap<K, V>(capacity, 0.75f, true) {
            @Override
            protected boolean removeEldestEntry(Map.Entry<K, V> eldest) {
                return size() > capacity;
            }
        };
    }

    public V get(K key) {
        return cache.get(key);
    }

    public void put(K key, V value) {
        cache.put(key, value);
    }
}

```

### 7.2 ì´ë²¤íŠ¸ ì²˜ë¦¬ ì‹œìŠ¤í…œ

```java
public class EventSystem {
    private final Map<String, List<EventHandler>> handlers =
        new ConcurrentHashMap<>();

    public void register(String event, EventHandler handler) {
        handlers.computeIfAbsent(event, k -> new CopyOnWriteArrayList<>())
               .add(handler);
    }

    public void trigger(String event) {
        List<EventHandler> eventHandlers = handlers.get(event);
        if (eventHandlers != null) {
            eventHandlers.forEach(EventHandler::handle);
        }
    }
}

```

## 8. ì»¬ë ‰ì…˜ ì¸í„°í˜ì´ìŠ¤ ğŸ”

### 8.1 Collection ì¸í„°í˜ì´ìŠ¤

### ì£¼ìš” ë©”ì„œë“œ âš™ï¸

```java
// ê¸°ë³¸ ì—°ì‚°
boolean add(E element)
boolean remove(Object element)
boolean contains(Object element)
int size()
boolean isEmpty()

// ë²Œí¬ ì—°ì‚°
boolean addAll(Collection<? extends E> c)
boolean removeAll(Collection<?> c)
boolean retainAll(Collection<?> c)
void clear()

// ìŠ¤íŠ¸ë¦¼ ì—°ì‚° (JDK 8+)
Stream<E> stream()
Stream<E> parallelStream()

```

### ì¥ë‹¨ì  âš–ï¸

- **ì¥ì **
    - í‘œì¤€í™”ëœ ì¸í„°í˜ì´ìŠ¤
    - ë‹¤í˜•ì„± í™œìš© ê°€ëŠ¥
    - í’ë¶€í•œ API ì œê³µ
- **ë‹¨ì **
    - ê¸°ë³¸í˜• ë°ì´í„° ì²˜ë¦¬ ì‹œ ë°•ì‹±/ì–¸ë°•ì‹± ì˜¤ë²„í—¤ë“œ
    - ë™ê¸°í™” ì²˜ë¦¬ í•„ìš” ì‹œ ì¶”ê°€ ì‘ì—… í•„ìš”

## 9. íŠ¹ìˆ˜ ì»¬ë ‰ì…˜ ğŸ¯

### 9.1 ConcurrentCollections

### ConcurrentHashMap

```java
ConcurrentHashMap<String, Integer> concurrentMap = new ConcurrentHashMap<>();

// ì›ìì  ì—°ì‚°
concurrentMap.computeIfAbsent("key", k -> expensiveOperation(k));
concurrentMap.merge("key", 1, Integer::sum);

// ë³‘ë ¬ ì²˜ë¦¬
concurrentMap.forEach(1000, (k, v) -> process(k, v));

```

### íŠ¹ì§• âœ¨

- Lock Striping ê¸°ìˆ  ì‚¬ìš©
- ë™ì‹œì„± ë ˆë²¨ ì§€ì • ê°€ëŠ¥
- null ê°’ í—ˆìš©í•˜ì§€ ì•ŠìŒ
- ì½ê¸° ì‘ì—…ì— ëŒ€í•œ ë™ê¸°í™” ë¶ˆí•„ìš”

### 9.2 BlockingQueue

```java
BlockingQueue<Task> queue = new LinkedBlockingQueue<>(1000);

// ìƒì‚°ì
void producer() {
    queue.put(new Task()); // íê°€ ê°€ë“ ì°¨ë©´ ë¸”ë¡
}

// ì†Œë¹„ì
void consumer() {
    Task task = queue.take(); // íê°€ ë¹„ì–´ìˆìœ¼ë©´ ë¸”ë¡
}

```

## 10. ì»¬ë ‰ì…˜ ì„±ëŠ¥ ìµœì í™” ğŸš€

### 10.1 ë©”ëª¨ë¦¬ ìµœì í™”

```java
// ì»¤ìŠ¤í…€ ë¡œë“œíŒ©í„° ì„¤ì •
Map<String, String> map = new HashMap<>(1000, 0.6f);

// ë©”ëª¨ë¦¬ íš¨ìœ¨ì ì¸ ë¶ˆë³€ ì»¬ë ‰ì…˜
List<String> list = List.copyOf(sourceList); // JDK 10+

```

### 10.2 ë™ì‹œì„± ìµœì í™”

```java
// ì½ê¸° ì‘ì—…ì´ ë§ì€ ê²½ìš°
CopyOnWriteArrayList<String> cowList = new CopyOnWriteArrayList<>();

// ì“°ê¸° ì‘ì—…ì´ ë§ì€ ê²½ìš°
ConcurrentHashMap<String, Integer> chm = new ConcurrentHashMap<>();

```

## 11. ì»¬ë ‰ì…˜ í™œìš© íŒ¨í„´ ğŸ’¡

### 11.1 Composite Pattern

```java
public class CompositeCollection<E> implements Collection<E> {
    private final List<Collection<E>> collections = new ArrayList<>();

    public boolean add(Collection<E> collection) {
        return collections.add(collection);
    }

    @Override
    public boolean add(E e) {
        return collections.stream()
                        .anyMatch(c -> c.add(e));
    }

    // ... ê¸°íƒ€ Collection ë©”ì„œë“œ êµ¬í˜„
}

```

### 11.2 Observer Pattern with Collections

```java
public class ObservableList<E> extends ArrayList<E> {
    private final List<ListChangeListener<E>> listeners = new CopyOnWriteArrayList<>();

    public void addListener(ListChangeListener<E> listener) {
        listeners.add(listener);
    }

    @Override
    public boolean add(E e) {
        boolean added = super.add(e);
        if (added) {
            notifyListeners(e);
        }
        return added;
    }

    private void notifyListeners(E element) {
        listeners.forEach(l -> l.onElementAdded(element));
    }
}

```

## 12. ì»¬ë ‰ì…˜ ë””ë²„ê¹… ë° ë¬¸ì œ í•´ê²° ğŸ”§

### 12.1 ì¼ë°˜ì ì¸ ë¬¸ì œì ê³¼ í•´ê²°ë°©ì•ˆ

- **ConcurrentModificationException**
    
    ```java
    // ì˜ëª»ëœ ë°©ë²•
    for (String item : list) {
        if (condition) list.remove(item); // ì˜ˆì™¸ ë°œìƒ
    }
    
    // ì˜¬ë°”ë¥¸ ë°©ë²•
    list.removeIf(item -> condition);
    
    ```
    
- **ë©”ëª¨ë¦¬ ëˆ„ìˆ˜**
    
    ```java
    // ì˜ëª»ëœ ë°©ë²•
    static List<Object> cache = new ArrayList<>();
    
    // ì˜¬ë°”ë¥¸ ë°©ë²•
    static WeakHashMap<Key, Object> cache = new WeakHashMap<>();
    
    ```
    

### 12.2 ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§

```java
public class CollectionMetrics {
    private static final Map<String, Long> operationTimes = new ConcurrentHashMap<>();

    public static <T> T measureOperation(String operation, Supplier<T> action) {
        long start = System.nanoTime();
        T result = action.get();
        long end = System.nanoTime();

        operationTimes.merge(operation, end - start, Long::sum);
        return result;
    }

    public static Map<String, Long> getMetrics() {
        return new HashMap<>(operationTimes);
    }
}

```

## 13. ìµœì‹  ê¸°ëŠ¥ (JDK 17) ğŸ†•

### 13.1 Recordì™€ ì»¬ë ‰ì…˜

```java
record ImmutablePair<K, V>(K key, V value) {
    public static <K, V> Map<K, V> toMap(List<ImmutablePair<K, V>> pairs) {
        return pairs.stream()
                   .collect(Collectors.toUnmodifiableMap(
                       ImmutablePair::key,
                       ImmutablePair::value));
    }
}

```

### 13.2 íŒ¨í„´ ë§¤ì¹­

```java
public void processCollection(Collection<?> collection) {
    if (collection instanceof List<?> list) {
        // List íŠ¹í™” ì²˜ë¦¬
        processListElements(list);
    } else if (collection instanceof Set<?> set) {
        // Set íŠ¹í™” ì²˜ë¦¬
        processSetElements(set);
    }
}

```

## 14. ì»¬ë ‰ì…˜ ì„±ëŠ¥ ë¹„êµ ë° ì„ íƒ ê°€ì´ë“œ ğŸ“Š

### 14.1 ì£¼ìš” ì»¬ë ‰ì…˜ë³„ ì„±ëŠ¥ ë¹„êµ

| ì»¬ë ‰ì…˜ | ì¡°íšŒ | ì‚½ì…/ì‚­ì œ | ì •ë ¬ | ë©”ëª¨ë¦¬ | ë™ê¸°í™” |
| --- | --- | --- | --- | --- | --- |
| ArrayList | O(1) | O(n) | O(n log n) | ë‚®ìŒ | X |
| LinkedList | O(n) | O(1) | O(n log n) | ì¤‘ê°„ | X |
| HashSet | O(1) | O(1) | N/A | ì¤‘ê°„ | X |
| TreeSet | O(log n) | O(log n) | ìë™ | ë†’ìŒ | X |
| HashMap | O(1) | O(1) | N/A | ì¤‘ê°„ | X |
| TreeMap | O(log n) | O(log n) | ìë™ | ë†’ìŒ | X |
| ConcurrentHashMap | O(1) | O(1) | N/A | ì¤‘ê°„ | O |

### 14.2 ì‚¬ìš© ì‚¬ë¡€ë³„ ìµœì  ì»¬ë ‰ì…˜ ì„ íƒ

```java
// 1. ëŒ€ìš©ëŸ‰ ë°ì´í„° ìˆœì°¨ ì ‘ê·¼
List<Integer> largeDataSet = new ArrayList<>(10_000_000);

// 2. ë¹ˆë²ˆí•œ ì‚½ì…/ì‚­ì œ
List<String> frequentModification = new LinkedList<>();

// 3. ì •ë ¬ëœ ë°ì´í„° ìœ ì§€
NavigableSet<Integer> sortedSet = new TreeSet<>();

// 4. ë©€í‹°ìŠ¤ë ˆë“œ í™˜ê²½
Map<String, Integer> concurrentAccess = new ConcurrentHashMap<>();

// 5. ë©”ëª¨ë¦¬ ìµœì í™”
List<String> memoryEfficient = Arrays.asList(new String[1000]);

```

## 15. ê³ ê¸‰ ì»¬ë ‰ì…˜ ê¸°ëŠ¥ ğŸ”¥

### 15.1 Spliterator í™œìš©

```java
public class CustomSpliterator {
    public static void parallelProcessing(List<String> list) {
        Spliterator<String> spliterator = list.spliterator();

        // ë³‘ë ¬ ì²˜ë¦¬ë¥¼ ìœ„í•œ ë¶„í• 
        Spliterator<String> firstHalf = spliterator.trySplit();

        // ë³‘ë ¬ ì‹¤í–‰
        CompletableFuture.runAsync(() -> firstHalf.forEachRemaining(System.out::println));
        spliterator.forEachRemaining(System.out::println);
    }
}

```

### 15.2 ì‚¬ìš©ì ì •ì˜ ì •ë ¬

```java
public class CustomSort {
    public static void complexSort(List<Person> people) {
        Collections.sort(people,
            Comparator.comparing(Person::getAge)
                     .thenComparing(Person::getName)
                     .reversed());

        // Java 8+ ìŠ¤íŠ¸ë¦¼ í™œìš©
        List<Person> sorted = people.stream()
            .sorted(Comparator.comparing(Person::getSalary))
            .collect(Collectors.toList());
    }
}

```

## 16. ì»¬ë ‰ì…˜ í™•ì¥ ğŸ› ï¸

### 16.1 ì»¤ìŠ¤í…€ ì»¬ë ‰ì…˜ êµ¬í˜„

```java
public class BoundedList<E> extends ArrayList<E> {
    private final int maxSize;

    public BoundedList(int maxSize) {
        this.maxSize = maxSize;
    }

    @Override
    public boolean add(E element) {
        if (size() >= maxSize) {
            throw new IllegalStateException("List is full");
        }
        return super.add(element);
    }

    @Override
    public void add(int index, E element) {
        if (size() >= maxSize) {
            throw new IllegalStateException("List is full");
        }
        super.add(index, element);
    }
}

```

### 16.2 Thread-Safe ì»¬ë ‰ì…˜ êµ¬í˜„

```java
public class ThreadSafeList<E> {
    private final List<E> list = new ArrayList<>();
    private final ReadWriteLock lock = new ReentrantReadWriteLock();

    public void add(E element) {
        lock.writeLock().lock();
        try {
            list.add(element);
        } finally {
            lock.writeLock().unlock();
        }
    }

    public E get(int index) {
        lock.readLock().lock();
        try {
            return list.get(index);
        } finally {
            lock.readLock().unlock();
        }
    }
}

```

## 17. ì»¬ë ‰ì…˜ ìµœì í™” ê¸°ë²• ğŸ’ª

### 17.1 ì´ˆê¸° ìš©ëŸ‰ ìµœì í™”

```java
// ì˜ˆìƒ í¬ê¸°ë¥¼ ì•Œ ë•Œ ì´ˆê¸° ìš©ëŸ‰ ì„¤ì •
List<String> list = new ArrayList<>(10000);
Map<String, Integer> map = new HashMap<>(10000, 0.75f);

// ë²Œí¬ ì‚½ì… ìµœì í™”
List<Integer> numbers = new ArrayList<>(Arrays.asList(new Integer[1000]));
Collections.fill(numbers, 0);

```

### 17.2 ë©”ëª¨ë¦¬ ì‚¬ìš© ìµœì í™”

```java
public class MemoryEfficientList<E> {
    private static final int BATCH_SIZE = 1000;
    private final List<List<E>> chunks = new ArrayList<>();

    public void add(E element) {
        if (chunks.isEmpty() || getLast().size() >= BATCH_SIZE) {
            chunks.add(new ArrayList<>(BATCH_SIZE));
        }
        getLast().add(element);
    }

    private List<E> getLast() {
        return chunks.get(chunks.size() - 1);
    }
}

```

## 18. ì»¬ë ‰ì…˜ ë””ìì¸ íŒ¨í„´ ğŸ¨

### 18.1 Iterator íŒ¨í„´ êµ¬í˜„

```java
public class CustomIterator<E> implements Iterator<E> {
    private final List<E> elements;
    private int position = 0;

    public CustomIterator(List<E> elements) {
        this.elements = elements;
    }

    @Override
    public boolean hasNext() {
        return position < elements.size();
    }

    @Override
    public E next() {
        if (!hasNext()) {
            throw new NoSuchElementException();
        }
        return elements.get(position++);
    }
}

```

### 18.2 Visitor íŒ¨í„´

```java
public interface CollectionVisitor<T> {
    void visit(List<T> list);
    void visit(Set<T> set);
    void visit(Map<T, ?> map);
}

public class CollectionElement<T> {
    private Collection<T> collection;

    public void accept(CollectionVisitor<T> visitor) {
        if (collection instanceof List) {
            visitor.visit((List<T>) collection);
        } else if (collection instanceof Set) {
            visitor.visit((Set<T>) collection);
        }
    }
}

```
