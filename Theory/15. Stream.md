# ìŠ¤íŠ¸ë¦¼(Stream)

## 1. ìŠ¤íŠ¸ë¦¼ì˜ ì´í•´ ğŸ¯

### 1.1 ìŠ¤íŠ¸ë¦¼ì˜ ì •ì˜ì™€ ëª©ì 

ìŠ¤íŠ¸ë¦¼(Stream)ì€ Java 8ì—ì„œ ë„ì…ëœ ê¸°ëŠ¥ìœ¼ë¡œ, ì»¬ë ‰ì…˜ì´ë‚˜ ë°°ì—´ì˜ ìš”ì†Œë¥¼ ì„ ì–¸ì ìœ¼ë¡œ ì²˜ë¦¬í•  ìˆ˜ ìˆëŠ” API.

```java
// ì „í†µì ì¸ ë°©ì‹
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
int sum = 0;
for (Integer num : numbers) {
    if (num % 2 == 0) {
        sum += num;
    }
}

// ìŠ¤íŠ¸ë¦¼ ë°©ì‹
int sum = numbers.stream()
    .filter(num -> num % 2 == 0)
    .mapToInt(Integer::intValue)
    .sum();

```

### 1.2 ìŠ¤íŠ¸ë¦¼ì˜ í•µì‹¬ íŠ¹ì§•

1. **ì„ ì–¸í˜• í”„ë¡œê·¸ë˜ë°**
    - ëª…ë ¹í˜• í”„ë¡œê·¸ë˜ë°ì˜ "ì–´ë–»ê²Œ"ê°€ ì•„ë‹Œ "ë¬´ì—‡ì„" ì¤‘ì‹¬
    - ê°€ë…ì„±ê³¼ ìœ ì§€ë³´ìˆ˜ì„± í–¥ìƒ
2. **íŒŒì´í”„ë¼ì´ë‹**
    - ë©”ì„œë“œ ì²´ì´ë‹ì„ í†µí•œ ì—°ì‚° êµ¬ì„±
    - ì§€ì—° í‰ê°€(lazy evaluation) ì§€ì›
3. **ë‚´ë¶€ ë°˜ë³µ**
    - ì™¸ë¶€ ë°˜ë³µì(for, while)ê°€ ì•„ë‹Œ ë‚´ë¶€ ë°˜ë³µì ì‚¬ìš©
    - ìµœì í™”ëœ ìˆœíšŒ ë°©ì‹ ì œê³µ

### 1.3 ìŠ¤íŠ¸ë¦¼ vs ì»¬ë ‰ì…˜

```java
// ì»¬ë ‰ì…˜: ë°ì´í„° ì¤‘ì‹¬
List<String> list = new ArrayList<>();
list.add("A");
list.add("B");

// ìŠ¤íŠ¸ë¦¼: ê³„ì‚° ì¤‘ì‹¬
Stream<String> stream = list.stream()
    .map(String::toLowerCase);

```

| íŠ¹ì„± | ì»¬ë ‰ì…˜ | ìŠ¤íŠ¸ë¦¼ |
| --- | --- | --- |
| ë°ì´í„° ì ‘ê·¼ | ì§ì ‘ ì ‘ê·¼ | ìˆœì°¨ ì ‘ê·¼ |
| ì¬ì‚¬ìš©ì„± | ì—¬ëŸ¬ ë²ˆ ì‚¬ìš© ê°€ëŠ¥ | í•œ ë²ˆë§Œ ì‚¬ìš© ê°€ëŠ¥ |
| ì™¸ë¶€/ë‚´ë¶€ ë°˜ë³µ | ì™¸ë¶€ ë°˜ë³µ | ë‚´ë¶€ ë°˜ë³µ |
| ì €ì¥ ë°©ì‹ | ëª¨ë“  ê°’ì„ ë©”ëª¨ë¦¬ì— ì €ì¥ | í•„ìš”í•  ë•Œ ê°’ì„ ê³„ì‚° |

## 2. ìŠ¤íŠ¸ë¦¼ ìƒì„±ì˜ ë‹¤ì–‘í•œ ë°©ë²• ğŸ’«

### 2.1 ì»¬ë ‰ì…˜ìœ¼ë¡œë¶€í„° ìƒì„±

```java
// Listë¡œë¶€í„° ìƒì„±
List<String> list = Arrays.asList("a", "b", "c");
Stream<String> stream = list.stream();

// Setìœ¼ë¡œë¶€í„° ìƒì„±
Set<String> set = new HashSet<>(Arrays.asList("a", "b", "c"));
Stream<String> setStream = set.stream();

// Mapìœ¼ë¡œë¶€í„° ìƒì„±
Map<String, Integer> map = new HashMap<>();
map.put("A", 1);
map.put("B", 2);

// í‚¤ ìŠ¤íŠ¸ë¦¼
Stream<String> keyStream = map.keySet().stream();

// ê°’ ìŠ¤íŠ¸ë¦¼
Stream<Integer> valueStream = map.values().stream();

// ì—”íŠ¸ë¦¬ ìŠ¤íŠ¸ë¦¼
Stream<Map.Entry<String, Integer>> entryStream = map.entrySet().stream();

```

### 2.2 ë°°ì—´ë¡œë¶€í„° ìƒì„±

```java
// ë°°ì—´ë¡œë¶€í„° ì§ì ‘ ìƒì„±
String[] arr = {"a", "b", "c"};
Stream<String> stream = Arrays.stream(arr);

// ë¶€ë¶„ ë°°ì—´ë¡œë¶€í„° ìƒì„±
Stream<String> partStream = Arrays.stream(arr, 1, 3);

// ê¸°ë³¸ íƒ€ì… ë°°ì—´
int[] intArr = {1, 2, 3, 4, 5};
IntStream intStream = Arrays.stream(intArr);

```

### 2.3 ë¹Œë”ë¥¼ ì‚¬ìš©í•œ ìƒì„±

```java
// Stream.builder() ì‚¬ìš©
Stream<String> built = Stream.<String>builder()
    .add("a")
    .add("b")
    .add("c")
    .build();

// generate() ë©”ì„œë“œ ì‚¬ìš©
Stream<Double> randoms = Stream.generate(Math::random)
    .limit(5);

// iterate() ë©”ì„œë“œ ì‚¬ìš©
Stream<Integer> evenNumbers = Stream.iterate(0, n -> n + 2)
    .limit(5);

```

## 3. ì¤‘ê°„ ì—°ì‚°ì˜ ì‹¬í™” í™œìš© ğŸ”„

### 3.1 ê³ ê¸‰ í•„í„°ë§ ê¸°ë²•

```java
// ë³µí•© ì¡°ê±´ í•„í„°ë§
Stream<Employee> complexFiltered = employees.stream()
    .filter(e -> e.getSalary() > 50000)
    .filter(e -> e.getDepartment().equals("IT"))
    .filter(e -> e.getAge() > 30);

// distinct()ì™€ í•¨ê»˜ ì‚¬ìš©
Stream<String> uniqueNames = employees.stream()
    .map(Employee::getName)
    .distinct()
    .filter(name -> name.startsWith("A"));

```

### 3.2 ê³ ê¸‰ ë§¤í•‘ ê¸°ë²•

```java
// flatMapì„ ì‚¬ìš©í•œ ì¤‘ì²© êµ¬ì¡° ì²˜ë¦¬
List<List<String>> nestedList = Arrays.asList(
    Arrays.asList("a", "b"),
    Arrays.asList("c", "d")
);

Stream<String> flatStream = nestedList.stream()
    .flatMap(Collection::stream);

// ê°ì²´ ë³€í™˜ê³¼ ë§¤í•‘
Stream<EmployeeDTO> dtoStream = employees.stream()
    .map(employee -> new EmployeeDTO(
        employee.getName(),
        employee.getSalary(),
        employee.getDepartment()
    ));

```

### 3.3 ì‚¬ìš©ì ì •ì˜ ì •ë ¬

```java
// ë³µí•© ì •ë ¬ ì¡°ê±´
Stream<Employee> sortedEmployees = employees.stream()
    .sorted(Comparator
        .comparing(Employee::getDepartment)
        .thenComparing(Employee::getSalary, Comparator.reverseOrder())
        .thenComparing(Employee::getName)
    );

// null ì²˜ë¦¬ë¥¼ í¬í•¨í•œ ì •ë ¬
Stream<String> sortedWithNull = Stream.of("b", null, "a", "c")
    .sorted(Comparator.nullsLast(String::compareTo));

```

## 4. ìµœì¢… ì—°ì‚°ì˜ ê³ ê¸‰ í™œìš© ğŸ¯

### 4.1 ê³ ê¸‰ ìˆ˜ì§‘ ì—°ì‚°

```java
// ë³µì¡í•œ ê·¸ë£¹í™”
Map<Department, Map<EmployeeLevel, List<Employee>>> groupedEmployees =
    employees.stream()
        .collect(Collectors.groupingBy(
            Employee::getDepartment,
            Collectors.groupingBy(Employee::getLevel)
        ));

// ì‚¬ìš©ì ì •ì˜ ìˆ˜ì§‘
class CustomCollector implements Collector<Employee, List<Employee>, List<Employee>> {
    @Override
    public Supplier<List<Employee>> supplier() {
        return ArrayList::new;
    }

    @Override
    public BiConsumer<List<Employee>, Employee> accumulator() {
        return List::add;
    }

    @Override
    public BinaryOperator<List<Employee>> combiner() {
        return (list1, list2) -> {
            list1.addAll(list2);
            return list1;
        };
    }

    @Override
    public Function<List<Employee>, List<Employee>> finisher() {
        return Function.identity();
    }

    @Override
    public Set<Characteristics> characteristics() {
        return EnumSet.of(Characteristics.IDENTITY_FINISH);
    }
}

```

### 4.2 ê³ ê¸‰ ë¦¬ë•ì…˜ ì—°ì‚°

```java
// ë³µì¡í•œ reduce ì—°ì‚°
Optional<Employee> seniorEmployee = employees.stream()
    .reduce((e1, e2) ->
        e1.getYearsOfService() > e2.getYearsOfService() ? e1 : e2
    );

// ë‹¤ì¤‘ ê²°ê³¼ ë¦¬ë•ì…˜
class SalaryStats {
    double sum;
    int count;
    double min;
    double max;

    public void accept(Employee employee) {
        sum += employee.getSalary();
        count++;
        min = Math.min(min, employee.getSalary());
        max = Math.max(max, employee.getSalary());
    }

    public SalaryStats combine(SalaryStats other) {
        sum += other.sum;
        count += other.count;
        min = Math.min(min, other.min);
        max = Math.max(max, other.max);
        return this;
    }
}

SalaryStats stats = employees.stream()
    .collect(Collector.of(
        SalaryStats::new,
        SalaryStats::accept,
        SalaryStats::combine
    ));

```

## 5. ìŠ¤íŠ¸ë¦¼ì˜ ì„±ëŠ¥ ìµœì í™” âš¡

### 5.1 ë³‘ë ¬ ìŠ¤íŠ¸ë¦¼ ìµœì í™”

```java
// ë³‘ë ¬ ì²˜ë¦¬ì— ì í•©í•œ ë°ì´í„° êµ¬ì¡° ì„ íƒ
List<Integer> numbers = new ArrayList<>();  // ì¢‹ìŒ
LinkedList<Integer> linked = new LinkedList<>();  // ë‚˜ì¨

// ë³‘ë ¬ ì²˜ë¦¬ ì„±ëŠ¥ ì¸¡ì •
long start = System.nanoTime();
double result = numbers.parallelStream()
    .mapToDouble(i -> compute(i))
    .average()
    .orElse(0.0);
long end = System.nanoTime();
System.out.printf("ì²˜ë¦¬ ì‹œê°„: %d ms%n", (end - start) / 1_000_000);

```

### 5.2 ë©”ëª¨ë¦¬ ì‚¬ìš© ìµœì í™”

```java
// ë¬´í•œ ìŠ¤íŠ¸ë¦¼ ì œì–´
Stream<Integer> infiniteStream = Stream.iterate(0, i -> i + 1)
    .limit(1000);  // ì œí•œ ì„¤ì •

// ëŒ€ìš©ëŸ‰ ë°ì´í„° ì²˜ë¦¬
try (Stream<String> lines = Files.lines(Paths.get("large-file.txt"))) {
    lines.filter(line -> line.contains("ERROR"))
         .forEach(System.out::println);
}

```

## 6. ìŠ¤íŠ¸ë¦¼ ë””ë²„ê¹…ê³¼ í…ŒìŠ¤íŒ… ğŸ”

### 6.1 ë””ë²„ê¹… ê¸°ë²•

```java
// peek()ë¥¼ ì‚¬ìš©í•œ ë‹¨ê³„ë³„ ëª¨ë‹ˆí„°ë§
List<String> result = stream
    .peek(e -> System.out.println("Original: " + e))
    .filter(e -> e.length() > 3)
    .peek(e -> System.out.println("Filtered: " + e))
    .map(String::toUpperCase)
    .peek(e -> System.out.println("Mapped: " + e))
    .collect(Collectors.toList());

// ë¡œê¹…ì„ í¬í•¨í•œ ë””ë²„ê¹…
Stream<String> debugStream = stream
    .peek(e -> log.debug("Processing element: {}", e));

```

### 6.2 í…ŒìŠ¤íŠ¸ ì‘ì„±

```java
@Test
void testStreamOperations() {
    List<String> input = Arrays.asList("a", "bb", "ccc");

    List<String> result = input.stream()
        .filter(s -> s.length() > 1)
        .map(String::toUpperCase)
        .collect(Collectors.toList());

    assertThat(result)
        .hasSize(2)
        .contains("BB", "CCC");
}

```

## 7. ìŠ¤íŠ¸ë¦¼ í™œìš© ëª¨ë²” ì‚¬ë¡€ ë° ì•ˆí‹°íŒ¨í„´ âš ï¸

### 7.1 ëª¨ë²” ì‚¬ë¡€

```java
// 1. ì ì ˆí•œ ì¤‘ê°„ ì—°ì‚° ìˆœì„œ
stream
    .filter(expensive::test)    // ë¹„ìš©ì´ ë†’ì€ í•„í„°ë¥¼ ë‚˜ì¤‘ì—
    .filter(cheap::test)       // ë¹„ìš©ì´ ë‚®ì€ í•„í„°ë¥¼ ë¨¼ì €
    .map(expensive::transform);

// 2. ëª…í™•í•œ ë©”ì„œë“œ ì°¸ì¡° ì‚¬ìš©
stream
    .map(Person::getName)      // ì¢‹ìŒ
    .map(person -> person.getName());  // ë¶ˆí•„ìš”í•˜ê²Œ ì¥í™©

// 3. ì ì ˆí•œ ì»¬ë ‰í„° ì„ íƒ
Map<String, List<Person>> peopleByCity = people.stream()
    .collect(Collectors.groupingBy(Person::getCity));

```

### 7.2 ì•ˆí‹°íŒ¨í„´

```java
// 1. ìŠ¤íŠ¸ë¦¼ ì¬ì‚¬ìš© ì‹œë„ (ì˜ëª»ëœ ì˜ˆ)
Stream<String> stream = list.stream();
stream.forEach(System.out::println);
stream.forEach(System.out::println);  // IllegalStateException

// 2. ì™¸ë¶€ ìƒíƒœ ë³€ê²½ (ì˜ëª»ëœ ì˜ˆ)
int[] sum = new int[1];
stream.forEach(i -> sum[0] += i);  // ë¶€ì‘ìš© ë°œìƒ

// 3. ë¶ˆí•„ìš”í•œ ë³‘ë ¬í™” (ì˜ëª»ëœ ì˜ˆ)
List<String> result = smallList.parallelStream()  // ì˜¤ë²„í—¤ë“œ ë°œìƒ
    .map(String::toUpperCase)
    .collect(Collectors.toList());

```

## 8. ì‹¤ì „ ì‘ìš© ì˜ˆì œ ğŸ“š

### 8.1 ë³µì¡í•œ ë°ì´í„° ì²˜ë¦¬

```java
// ë¶€ì„œë³„ í‰ê·  ê¸‰ì—¬ê°€ ê°€ì¥ ë†’ì€ ìƒìœ„ 3ê°œ ë¶€ì„œ ì°¾ê¸°
Map<String, Double> topDepartments = employees.stream()
    .collect(Collectors.groupingBy(
        Employee::getDepartment,
        Collectors.averagingDouble(Employee::getSalary)
    ))
    .entrySet().stream()
    .sorted(Map.Entry.<String, Double>comparingByValue().reversed())
    .limit(3)
    .collect(Collectors.toMap(
        Map.Entry::getKey,
        Map.Entry::getValue,
        (e1, e2) -> e1,
        LinkedHashMap::new
    ));

// ì§ì›ë“¤ì˜ ê¸‰ì—¬ í†µê³„ ê³„ì‚°
DoubleSummaryStatistics salaryStats = employees.stream()
    .mapToDouble(Employee::getSalary)
    .summaryStatistics();

```

### 8.2 íŒŒì¼ ì²˜ë¦¬ì™€ I/O ìŠ¤íŠ¸ë¦¼ í™œìš©

```java
// ë¡œê·¸ íŒŒì¼ ë¶„ì„
try (Stream<String> lines = Files.lines(Paths.get("server.log"))) {
    Map<String, Long> errorCounts = lines
        .filter(line -> line.contains("ERROR"))
        .map(line -> line.split(":")[1].trim())
        .collect(Collectors.groupingBy(
            Function.identity(),
            Collectors.counting()
        ));
}

// CSV íŒŒì¼ ì²˜ë¦¬ì™€ ë°ì´í„° ë³€í™˜
try (Stream<String> lines = Files.lines(Paths.get("data.csv"))) {
    List<Employee> employees = lines
        .skip(1)  // í—¤ë” ê±´ë„ˆë›°ê¸°
        .map(line -> line.split(","))
        .map(parts -> new Employee(
            parts[0],
            parts[1],
            Double.parseDouble(parts[2])
        ))
        .collect(Collectors.toList());
}

```

## 9. ìŠ¤íŠ¸ë¦¼ì˜ ê³ ê¸‰ í™œìš© íŒ¨í„´ ğŸ¨

### 9.1 ì»¤ìŠ¤í…€ ì»¬ë ‰í„° êµ¬í˜„

```java
public class CustomGroupingCollector<T> implements Collector<T, Map<String, List<T>>, Map<String, List<T>>> {
    private final Function<T, String> classifier;

    public CustomGroupingCollector(Function<T, String> classifier) {
        this.classifier = classifier;
    }

    @Override
    public Supplier<Map<String, List<T>>> supplier() {
        return HashMap::new;
    }

    @Override
    public BiConsumer<Map<String, List<T>>, T> accumulator() {
        return (map, element) -> {
            String key = classifier.apply(element);
            map.computeIfAbsent(key, k -> new ArrayList<>())
               .add(element);
        };
    }

    @Override
    public BinaryOperator<Map<String, List<T>>> combiner() {
        return (map1, map2) -> {
            map2.forEach((key, value) ->
                map1.merge(key, value, (list1, list2) -> {
                    list1.addAll(list2);
                    return list1;
                })
            );
            return map1;
        };
    }

    @Override
    public Function<Map<String, List<T>>, Map<String, List<T>>> finisher() {
        return Function.identity();
    }

    @Override
    public Set<Characteristics> characteristics() {
        return EnumSet.of(Characteristics.IDENTITY_FINISH);
    }
}

```

### 9.2 ë³µí•© ìŠ¤íŠ¸ë¦¼ ì—°ì‚°

```java
// ë‹¤ì¤‘ ì¡°ê±´ í•„í„°ë§ê³¼ ë³€í™˜
public List<EmployeeDTO> getHighPerformingITEmployees(List<Employee> employees) {
    return employees.stream()
        .filter(e -> e.getDepartment().equals("IT"))
        .filter(e -> e.getPerformanceScore() > 4.0)
        .filter(e -> e.getYearsOfService() >= 2)
        .sorted(Comparator.comparing(Employee::getSalary).reversed())
        .map(e -> new EmployeeDTO(
            e.getName(),
            e.getSalary() * 1.1,  // 10% ê¸‰ì—¬ ì¸ìƒ
            e.getDepartment()
        ))
        .limit(5)
        .collect(Collectors.toList());
}

// ì¤‘ì²©ëœ ë°ì´í„° êµ¬ì¡° ì²˜ë¦¬
public Map<String, Set<String>> getProjectTechnologies(List<Project> projects) {
    return projects.stream()
        .collect(Collectors.groupingBy(
            Project::getDepartment,
            Collectors.flatMapping(
                project -> project.getTechnologies().stream(),
                Collectors.toCollection(TreeSet::new)
            )
        ));
}

```

### 9.3 ìŠ¤íŠ¸ë¦¼ ì„±ëŠ¥ ìµœì í™” ê¸°ë²•

```java
// 1. ë³‘ë ¬ ìŠ¤íŠ¸ë¦¼ ì‚¬ìš© ì‹œ ì ì ˆí•œ ë¶„í•  í¬ê¸° ì„¤ì •
public static final int THRESHOLD = 10_000;

public double calculateAverageInParallel(List<Transaction> transactions) {
    return transactions.size() > THRESHOLD ?
        transactions.parallelStream()
            .mapToDouble(Transaction::getAmount)
            .average()
            .orElse(0.0)
        :
        transactions.stream()
            .mapToDouble(Transaction::getAmount)
            .average()
            .orElse(0.0);
}

// 2. ìŠ¤íŠ¸ë¦¼ ì²´ì´ë‹ ìµœì í™”
public List<Employee> optimizedEmployeeProcessing(List<Employee> employees) {
    return employees.stream()
        .filter(e -> e.getSalary() > 50000)  // ë¹ ë¥¸ í•„í„° ë¨¼ì €
        .filter(e -> e.getDepartment().equals("IT"))  // ê·¸ ë‹¤ìŒ ë¬¸ìì—´ ë¹„êµ
        .filter(e -> isEligibleForPromotion(e))  // ë³µì¡í•œ ê²€ì¦ì€ ë§ˆì§€ë§‰
        .collect(Collectors.toList());
}

```

## 10. ìŠ¤íŠ¸ë¦¼ ë””ë²„ê¹…ê³¼ ìœ ì§€ë³´ìˆ˜ ğŸ› ï¸

### 10.1 ë””ë²„ê¹…ì„ ìœ„í•œ ë¡œê¹… ìœ í‹¸ë¦¬í‹°

```java
public class StreamDebugger {
    private static final Logger log = LoggerFactory.getLogger(StreamDebugger.class);

    public static <T> Consumer<T> logElement(String prefix) {
        return element -> log.debug("{}: {}", prefix, element);
    }

    public static <T> Consumer<T> logElementWithThread(String prefix) {
        return element -> log.debug("{} - Thread {}: {}",
            prefix, Thread.currentThread().getName(), element);
    }
}

// ì‚¬ìš© ì˜ˆì œ
employees.stream()
    .peek(StreamDebugger.logElement("Original"))
    .filter(e -> e.getSalary() > 50000)
    .peek(StreamDebugger.logElement("Filtered"))
    .map(Employee::getName)
    .peek(StreamDebugger.logElementWithThread("Mapped"))
    .collect(Collectors.toList());

```

### 10.2 í…ŒìŠ¤íŠ¸ ê°€ëŠ¥í•œ ìŠ¤íŠ¸ë¦¼ ì„¤ê³„

```java
@Test
void testEmployeeStreamProcessing() {
    // í…ŒìŠ¤íŠ¸ ë°ì´í„° ì¤€ë¹„
    List<Employee> employees = Arrays.asList(
        new Employee("John", "IT", 60000),
        new Employee("Alice", "HR", 45000),
        new Employee("Bob", "IT", 55000)
    );

    // ìŠ¤íŠ¸ë¦¼ ì²˜ë¦¬ ê²°ê³¼ ê²€ì¦
    List<EmployeeDTO> result = processEmployees(employees);

    assertThat(result)
        .hasSize(2)
        .extracting("name", "department")
        .containsExactly(
            tuple("John", "IT"),
            tuple("Bob", "IT")
        );
}

```
