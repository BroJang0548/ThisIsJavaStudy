# 📚 객체 지향 프로그래밍

## 📌 목차

1. [기본 개념](https://www.notion.so/e3703711c20d4884bca91f392581b6c3?pvs=21)
2. [클래스와 객체](https://www.notion.so/e3703711c20d4884bca91f392581b6c3?pvs=21)
3. [새로운 기능들](https://www.notion.so/e3703711c20d4884bca91f392581b6c3?pvs=21)
4. [객체지향 설계 원칙](https://www.notion.so/e3703711c20d4884bca91f392581b6c3?pvs=21)
5. [디자인 패턴](https://www.notion.so/e3703711c20d4884bca91f392581b6c3?pvs=21)

## 🎯 기본 개념

### 💡 객체란?

### 정의

- 물리적으로 존재하거나 개념적인 것 중 식별 가능한 것
- 속성(필드)과 동작(메소드)으로 구성

### 예시

- 자동차
    - 속성: 색상, 모델명
    - 동작: 달린다, 멈춘다

### 특징

- 식별 가능성
- 상태와 행동 보유
- 다른 객체와 상호작용

### 🔄 객체의 상호작용

### 기본 개념

- 객체들은 서로 메시지를 주고받으며 동작
- 메소드 호출을 통한 통신

### 예시 코드

```java
class Calculator {
    int add(int a, int b) {
        return a + b;
    }
}

class Person {
    void useCalculator() {
        Calculator calc = new Calculator();
        int result = calc.add(5, 3); // 객체 간 상호작용
    }
}

```

### 🔗 객체 간의 관계 (Object Relationships)

## 📚 목차

1. [집합 관계 (Composition)](https://www.notion.so/e3703711c20d4884bca91f392581b6c3?pvs=21)
2. [연관 관계 (Association)](https://www.notion.so/e3703711c20d4884bca91f392581b6c3?pvs=21)
3. [상속 관계 (Inheritance)](https://www.notion.so/e3703711c20d4884bca91f392581b6c3?pvs=21)
4. [의존 관계 (Dependency)](https://www.notion.so/e3703711c20d4884bca91f392581b6c3?pvs=21)
5. [실전 응용](https://www.notion.so/e3703711c20d4884bca91f392581b6c3?pvs=21)

### 💎 집합 관계 (Composition)

### 📌 개념

- 전체(whole)와 부분(part)의 관계
- 부분 객체가 전체 객체에 속하는 관계
- 생명주기가 전체 객체에 종속됨

### ⭐️ 특징

1. **강한 결합도**
    - 부분 객체는 전체 객체에 완전히 종속
    - 전체 객체가 소멸하면 부분 객체도 소멸
2. **생명주기 관리**
    - 전체 객체가 부분 객체의 생성과 소멸을 담당
    - 부분 객체는 독립적으로 존재할 수 없음
3. **배타적 소유**
    - 부분 객체는 하나의 전체 객체에만 속함
    - 다른 객체와 공유되지 않음

### 💡 사용 목적

1. **복잡한 객체의 구조화**
    - 큰 객체를 작은 단위로 분할
    - 관리의 용이성 증가
2. **재사용성 향상**
    - 부품화를 통한 모듈성 증가
    - 유지보수 용이성 향상
3. **캡슐화 강화**
    - 내부 구현 상세를 숨김
    - 외부 의존성 감소

### 📝 예제 코드

```java
public class Car {
    // 부분 객체들
    private final Engine engine;
    private final Transmission transmission;
    private final Wheel[] wheels;

    // 전체 객체가 부분 객체들을 생성하고 관리
    public Car() {
        this.engine = new Engine();
        this.transmission = new Transmission();
        this.wheels = new Wheel[4];
        for (int i = 0; i < 4; i++) {
            this.wheels[i] = new Wheel();
        }
    }

    // Car가 소멸하면 모든 부분 객체도 함께 소멸
}

class Engine {
    private int horsePower;
    private boolean isRunning;

    public void start() {
        isRunning = true;
    }

    public void stop() {
        isRunning = false;
    }
}

class Transmission {
    private int currentGear;

    public void shiftUp() {
        if (currentGear < 6) currentGear++;
    }

    public void shiftDown() {
        if (currentGear > 1) currentGear--;
    }
}

class Wheel {
    private double pressure;
    private boolean isFlat;

    public void inflate(double pressure) {
        this.pressure = pressure;
        this.isFlat = false;
    }
}

```

### ⚠️ 주의사항

1. **메모리 관리**
    - 순환 참조 주의
    - 적절한 자원 해제 필요
2. **결합도 고려**
    - 너무 강한 결합은 유연성 저하
    - 적절한 추상화 수준 유지
3. **테스트 용이성**
    - 단위 테스트가 어려울 수 있음
    - Mock 객체 사용 고려

### 🤝 연관 관계 (Association)

### 📌 정의

- 객체들이 서로 독립적으로 존재하면서 관계를 맺음
- 느슨한 결합을 통한 유연한 협력 관계
- 생명주기가 독립적

### 🎯 사용 목적

1. **객체 간 협력**
    - 기능 구현을 위한 상호작용
    - 책임의 분배와 협력
2. **유연한 설계**
    - 느슨한 결합을 통한 확장성
    - 재사용성 향상

### ⚡️ 특징

1. **독립적 생명주기**
    - 각 객체는 독립적으로 생성/소멸
    - 서로의 생명주기에 영향을 주지 않음
2. **방향성**
    - 단방향 또는 양방향 관계 가능
    - 탐색 방향에 따른 접근성 결정

### 💻 예제 코드

```java
public class Student {
    private List<Course> courses;

    public void enrollCourse(Course course) {
        if (courses == null) {
            courses = new ArrayList<>();
        }
        courses.add(course);
        course.addStudent(this);
    }
}

public class Course {
    private List<Student> students;

    public void addStudent(Student student) {
        if (students == null) {
            students = new ArrayList<>();
        }
        students.add(student);
    }
}

```

### ⚠️ 주의사항

1. **관계의 방향성 고려**
    - 단방향/양방향 선택 시 신중한 판단
    - 불필요한 양방향 관계 지양
2. **순환 참조 관리**
    - 양방향 관계에서의 순환 참조 주의
    - 적절한 객체 해제 메커니즘 구현

### 👨‍👦 상속 관계 (Inheritance)

### 📌 정의

- 기존 클래스의 속성과 기능을 물려받음
- 계층적 관계 구조 형성
- 코드 재사용과 확장성 제공

### 🎯 사용 목적

1. **코드 재사용**
    - 공통 기능의 중복 제거
    - 유지보수성 향상
2. **다형성 구현**
    - 유연한 설계 가능
    - 확장성 확보

### ⚡️ 특징

1. **IS-A 관계**
    - 하위 클래스는 상위 클래스의 한 종류
    - 대체 가능성 보장
2. **기능 확장**
    - 기존 기능 재정의 가능
    - 새로운 기능 추가 가능

### 💻 예제 코드

```java
public class Animal {
    protected String name;

    public void eat() {
        System.out.println("음식을 먹습니다.");
    }
}

public class Dog extends Animal {
    private String breed;

    @Override
    public void eat() {
        System.out.println("사료를 먹습니다.");
    }

    public void bark() {
        System.out.println("멍멍!");
    }
}

```

### ⚠️ 주의사항

1. **과도한 상속 지양**
    - 상속 계층이 깊어지면 복잡도 증가
    - 컴포지션 사용 고려
2. **LSP(리스코프 치환 원칙) 준수**
    - 하위 클래스는 상위 클래스를 대체할 수 있어야 함
    - 기존 동작 보장 필요

### 📦 의존 관계 (Dependency)

## 📌 정의

- 한 클래스가 다른 클래스를 사용하는 관계
- 일시적인 관계로, 메서드 내에서 지역변수로 사용하거나 파라미터로 전달받는 경우
- 가장 약한 결합도를 가지는 관계

## 🎯 사용 목적

1. **느슨한 결합도**
    - 객체 간 결합도를 최소화
    - 유연한 설계 구현
2. **재사용성 향상**
    - 의존성 주입을 통한 유연한 구현
    - 테스트 용이성 확보
3. **변경 영향도 최소화**
    - 한 클래스의 변경이 다른 클래스에 미치는 영향 감소
    - 유지보수성 향상

## ⚡️ 특징

1. **일시적 관계**
    - 메서드 실행 동안만 관계 유지
    - 객체의 참조를 유지하지 않음
2. **방향성**
    - 단방향 관계
    - 의존하는 쪽에서만 관계를 알고 있음
3. **다양한 형태**
    - 매개변수로 전달
    - 지역변수로 생성
    - 정적 메서드 호출

## 💻 예제 코드

### 1. 메서드 파라미터를 통한 의존

```java
public class OrderProcessor {
    public void processOrder(Order order, PaymentGateway gateway) {
        // PaymentGateway에 일시적으로 의존
        if (gateway.processPayment(order.getAmount())) {
            order.setStatus(OrderStatus.PAID);
        }
    }
}

```

### 2. 지역변수를 통한 의존

```java
public class EmailService {
    public void sendWelcomeEmail(User user) {
        // EmailValidator에 일시적으로 의존
        EmailValidator validator = new EmailValidator();
        if (validator.isValid(user.getEmail())) {
            // 이메일 발송 로직
        }
    }
}

```

### 3. 정적 메서드 호출을 통한 의존

```java
public class PriceCalculator {
    public double calculateDiscount(double price) {
        // MathUtils에 의존
        return MathUtils.round(price * 0.9);
    }
}

```

## 🔄 의존성 주입 (Dependency Injection)

### 1. 생성자 주입

```java
public class UserService {
    private final UserRepository userRepository;
    private final EmailService emailService;

    public UserService(UserRepository userRepository, EmailService emailService) {
        this.userRepository = userRepository;
        this.emailService = emailService;
    }
}

```

### 2. 세터 주입

```java
public class OrderService {
    private PaymentService paymentService;

    public void setPaymentService(PaymentService paymentService) {
        this.paymentService = paymentService;
    }
}

```

### 3. 인터페이스를 통한 의존성 추상화

```java
public interface Logger {
    void log(String message);
}

public class FileLogger implements Logger {
    @Override
    public void log(String message) {
        // 파일에 로그 기록
    }
}

public class ConsoleLogger implements Logger {
    @Override
    public void log(String message) {
        System.out.println(message);
    }
}

public class UserManager {
    private final Logger logger;

    public UserManager(Logger logger) {
        this.logger = logger;
    }
}

```

## ⚠️ 주의사항

### 1. 순환 의존성 방지

```java
// 피해야 할 예시
public class A {
    public void doSomething() {
        B b = new B();
        b.doSomething();
    }
}

public class B {
    public void doSomething() {
        A a = new A();
        a.doSomething();
    }
}

```

### 2. 인터페이스 활용

```java
// 권장되는 방식
public interface PaymentProcessor {
    void process(Payment payment);
}

public class CreditCardProcessor implements PaymentProcessor {
    @Override
    public void process(Payment payment) {
        // 신용카드 결제 처리
    }
}

```

### 3. 의존성 주입 컨테이너 활용

```java
public class Application {
    private final DependencyContainer container;

    public Application() {
        container = new DependencyContainer();
        container.register(Logger.class, new ConsoleLogger());
        container.register(UserRepository.class, new MySqlUserRepository());
    }

    public UserService createUserService() {
        return new UserService(
            container.resolve(UserRepository.class),
            container.resolve(Logger.class)
        );
    }
}

```

## 💡 모범 사례

### 1. 인터페이스 기반 설계

```java
public interface NotificationService {
    void notify(String message);
}

public class EmailNotification implements NotificationService {
    @Override
    public void notify(String message) {
        // 이메일 발송 구현
    }
}

public class SMSNotification implements NotificationService {
    @Override
    public void notify(String message) {
        // SMS 발송 구현
    }
}

```

### 2. 팩토리 패턴과 결합

```java
public class NotificationFactory {
    public NotificationService createNotificationService(String type) {
        return switch (type) {
            case "email" -> new EmailNotification();
            case "sms" -> new SMSNotification();
            default -> throw new IllegalArgumentException("Unknown type: " + type);
        };
    }
}

```

### 3. 테스트 용이성

```java
public class UserServiceTest {
    @Test
    public void testUserCreation() {
        // Mock 객체를 통한 의존성 대체
        UserRepository mockRepository = mock(UserRepository.class);
        EmailService mockEmailService = mock(EmailService.class);

        UserService userService = new UserService(mockRepository, mockEmailService);

        // 테스트 로직
    }
}

```

### 📦 실전 응용

### 1. 복합 관계 활용

```java
public class University {
    private List<Department> departments;  // 집합 관계
    private Dean dean;                     // 연관 관계

    public University() {
        this.departments = new ArrayList<>();
    }

    public void addDepartment(Department department) {
        departments.add(department);
    }

    public void setDean(Dean dean) {
        this.dean = dean;
    }
}

```

### 2. 디자인 패턴과 결합

```java
// 팩토리 메서드 패턴과 상속 관계 결합
public abstract class VehicleFactory {
    public abstract Vehicle createVehicle();

    public Vehicle orderVehicle() {
        Vehicle vehicle = createVehicle();
        vehicle.prepare();
        vehicle.assemble();
        vehicle.test();
        return vehicle;
    }
}

public class CarFactory extends VehicleFactory {
    @Override
    public Vehicle createVehicle() {
        return new Car();
    }
}

```

### 3. 의존성 주입 활용

```java
public class OrderService {
    private final PaymentProcessor paymentProcessor;
    private final NotificationService notificationService;

    public OrderService(
        PaymentProcessor paymentProcessor,
        NotificationService notificationService
    ) {
        this.paymentProcessor = paymentProcessor;
        this.notificationService = notificationService;
    }

    public void processOrder(Order order) {
        paymentProcessor.process(order);
        notificationService.notify(order);
    }
}

```

### 🎭 객체 지향의 특징

### 📦 1. 캡슐화 (Encapsulation)

### 📌 개념

- 데이터와 해당 데이터를 처리하는 메소드를 하나의 단위로 묶음
- 객체의 내부 구현을 외부로부터 감추는 정보 은닉
- 접근 제어를 통한 데이터 보호

### 🎯 사용 목적

1. **데이터 보호**
    - 외부로부터 데이터를 보호
    - 유효하지 않은 값 설정 방지
2. **유지보수성 향상**
    - 내부 구현 변경의 유연성 확보
    - 외부 영향 최소화

### ⚡️ 특징

1. **접근 제어자**
    - `private`: 같은 클래스 내에서만 접근 가능
    - `protected`: 같은 패키지와 자식 클래스에서 접근 가능
    - `package-private`(default): 같은 패키지 내에서만 접근 가능
    - `public`: 어디서든 접근 가능
2. **캡슐화 수준**
    
    ```java
    public class BankAccount {
        private double balance;  // 강한 캡슐화
        protected String accountType;  // 약한 캡슐화
        String branchCode;  // package-private
        public String accountNumber;  // 캡슐화 없음
    }
    
    ```
    

### 💻 예제 코드

```java
public class Employee {
    private String name;
    private double salary;
    private final String employeeId;

    // Record 패턴 (JDK 16+)
    public record EmployeeDetails(String name, String department) {}

    // 생성자
    public Employee(String name, double salary, String employeeId) {
        this.name = name;
        this.setSalary(salary);  // 유효성 검사를 위해 setter 사용
        this.employeeId = employeeId;
    }

    // Getter methods
    public String getName() {
        return name;
    }

    public double getSalary() {
        return salary;
    }

    public String getEmployeeId() {
        return employeeId;
    }

    // Setter with validation
    public void setSalary(double salary) {
        if (salary < 0) {
            throw new IllegalArgumentException("Salary cannot be negative");
        }
        this.salary = salary;
    }

    // 내부 데이터를 가공하여 제공하는 메소드
    public EmployeeDetails getEmployeeDetails() {
        return new EmployeeDetails(name, "IT");
    }
}

```

### ⚠️ 주의사항

1. **과도한 캡슐화 방지**
    - 불필요한 getter/setter 지양
    - 의미 있는 메소드 설계
2. **불변성 고려**
    - 가능한 한 `final` 필드 사용
    - 방어적 복사 구현

### 🔄 심화 응용

### 1. 불변 객체 설계

```java
public final class ImmutablePerson {
    private final String name;
    private final List<String> hobbies;

    public ImmutablePerson(String name, List<String> hobbies) {
        this.name = name;
        // 방어적 복사
        this.hobbies = new ArrayList<>(hobbies);
    }

    public String getName() {
        return name;
    }

    public List<String> getHobbies() {
        // 방어적 복사본 반환
        return new ArrayList<>(hobbies);
    }
}

```

### 2. 빌더 패턴 활용

```java
public class Person {
    private final String name;
    private final int age;
    private final String address;

    private Person(Builder builder) {
        this.name = builder.name;
        this.age = builder.age;
        this.address = builder.address;
    }

    public static class Builder {
        private String name;
        private int age;
        private String address;

        public Builder name(String name) {
            this.name = name;
            return this;
        }

        public Builder age(int age) {
            this.age = age;
            return this;
        }

        public Builder address(String address) {
            this.address = address;
            return this;
        }

        public Person build() {
            return new Person(this);
        }
    }
}

```

### 🔄 2. 상속 (Inheritance)

### 📌 개념

- 기존 클래스의 특성을 새로운 클래스가 재사용
- 계층적 관계를 통한 코드 재사용
- IS-A 관계 구현

### 🎯 사용 목적

1. **코드 재사용**
    - 공통 코드 중복 제거
    - 유지보수성 향상
2. **확장성**
    - 기존 코드 수정 없이 새로운 기능 추가
    - 다형성 구현 기반

### ⚡️ 특징 (JDK 17)

1. **sealed 클래스 (JDK 17)**
    - 상속 가능한 클래스를 명시적으로 제한
    - 더 안전한 클래스 계층 구조 설계
2. **다중 상속 제한**
    - 클래스의 다중 상속 불가
    - 인터페이스 다중 구현은 가능

### 💻 예제 코드

### 1. Sealed 클래스 활용

```java
public sealed class Shape
    permits Circle, Rectangle, Triangle {

    protected double area;

    public abstract double calculateArea();
}

public final class Circle extends Shape {
    private double radius;

    @Override
    public double calculateArea() {
        area = Math.PI * radius * radius;
        return area;
    }
}

public final class Rectangle extends Shape {
    private double width;
    private double height;

    @Override
    public double calculateArea() {
        area = width * height;
        return area;
    }
}

public final class Triangle extends Shape {
    private double base;
    private double height;

    @Override
    public double calculateArea() {
        area = (base * height) / 2;
        return area;
    }
}

```

### 2. 추상 클래스와 템플릿 메소드 패턴

```java
public abstract class DataMiner {
    // 템플릿 메소드
    public final void mine() {
        openFile();
        extractData();
        parseData();
        analyzeData();
        sendReport();
        closeFile();
    }

    abstract void extractData();
    abstract void parseData();

    // 훅 메소드
    protected void analyzeData() {
        // 기본 구현
    }

    private void openFile() {
        System.out.println("Opening file...");
    }

    private void closeFile() {
        System.out.println("Closing file...");
    }

    private void sendReport() {
        System.out.println("Sending report...");
    }
}

public class PDFDataMiner extends DataMiner {
    @Override
    void extractData() {
        System.out.println("Extracting data from PDF...");
    }

    @Override
    void parseData() {
        System.out.println("Parsing PDF data...");
    }
}

```

### ⚠️ 주의사항

1. **상속의 남용 방지**
    - 컴포지션 우선 고려
    - 깊은 상속 계층 지양
2. **LSP(리스코프 치환 원칙) 준수**
    
    ```java
    // 잘못된 예
    class Bird {
        void fly() { }
    }
    class Penguin extends Bird {  // 펭귄은 날 수 없음!
        @Override
        void fly() {
            throw new UnsupportedOperationException();
        }
    }
    
    // 올바른 예
    interface Flyable {
        void fly();
    }
    class Bird { }
    class Sparrow extends Bird implements Flyable {
        @Override
        public void fly() { }
    }
    class Penguin extends Bird { }
    
    ```
    

### 🎭 3. 다형성 (Polymorphism)

### 📌 개념

- 한 객체가 여러 타입의 형태를 가질 수 있는 능력
- 컴파일 타임 다형성(오버로딩)과 런타임 다형성(오버라이딩)
- 인터페이스를 통한 구현체의 교체 가능성

### 🎯 사용 목적

1. **유연한 설계**
    - 클라이언트 코드 변경 최소화
    - 확장성 있는 프로그램 구현
2. **코드 재사용**
    - 공통 인터페이스 활용
    - 중복 코드 제거

### ⚡️ 특징

1. **인터페이스 기반 프로그래밍**
    
    ```java
    public interface MessageSender {
        void send(String message);
    }
    
    public class EmailSender implements MessageSender {
        @Override
        public void send(String message) {
            System.out.println("Sending email: " + message);
        }
    }
    
    public class SMSSender implements MessageSender {
        @Override
        public void send(String message) {
            System.out.println("Sending SMS: " + message);
        }
    }
    
    ```
    
2. **제네릭을 활용한 다형성**
    
    ```java
    public interface Repository<T> {
        T findById(long id);
        void save(T entity);
        void delete(T entity);
    }
    
    public class UserRepository implements Repository<User> {
        @Override
        public User findById(long id) {
            // 구현
            return null;
        }
    
        @Override
        public void save(User entity) {
            // 구현
        }
    
        @Override
        public void delete(User entity) {
            // 구현
        }
    }
    
    ```
    

### 💻 고급 예제

### 1. 전략 패턴 구현

```java
public interface PaymentStrategy {
    void pay(int amount);
}

public class CreditCardPayment implements PaymentStrategy {
    private String cardNumber;

    public CreditCardPayment(String cardNumber) {
        this.cardNumber = cardNumber;
    }

    @Override
    public void pay(int amount) {
        System.out.println("Paid " + amount + " using Credit Card");
    }
}

public class PayPalPayment implements PaymentStrategy {
    private String emailId;

    public PayPalPayment(String emailId) {
        this.emailId = emailId;
    }

    @Override
    public void pay(int amount) {
        System.out.println("Paid " + amount + " using PayPal");
    }
}

public class ShoppingCart {
    private PaymentStrategy paymentStrategy;

    public void setPaymentStrategy(PaymentStrategy strategy) {
        this.paymentStrategy = strategy;
    }

    public void checkout(int amount) {
        paymentStrategy.pay(amount);
    }
}

```

### 2. 방문자 패턴

```java
public interface Element {
    void accept(Visitor visitor);
}

public interface Visitor {
    void visit(Circle circle);
    void visit(Rectangle rectangle);
}

public class Circle implements Element {
    private double radius;

    @Override
    public void accept(Visitor visitor) {
        visitor.visit(this);
    }
}

public class Rectangle implements Element {
    private double width;
    private double height;

    @Override
    public void accept(Visitor visitor) {
        visitor.visit(this);
    }
}

public class AreaCalculator implements Visitor {
    @Override
    public void visit(Circle circle) {
        // 원의 면적 계산
    }

    @Override
    public void visit(Rectangle rectangle) {
        // 사각형의 면적 계산
    }
}

```

### ⚠️ 주의사항

1. **instanceof 연산자 사용 최소화**
    
    ```java
    // 지양해야 할 코드
    if (animal instanceof Dog) {
        Dog dog = (Dog) animal;
        dog.bark();
    }
    
    // 권장되는 방식
    interface Animal {
        void makeSound();
    }
    
    ```
    
2. **타입 안전성 보장**
    
    ```java
    // 제네릭 사용
    public class SafeContainer<T> {
        private T content;
    
        public void set(T content) {
            this.content = content;
        }
    
        public T get() {
            return content;
        }
    }
    
    ```
    

### 🔄 실전 응용

### 1. 팩토리 메소드와 다형성

```java
public interface Logger {
    void log(String message);
}

public class ConsoleLogger implements Logger {
    @Override
    public void log(String message) {
        System.out.println("Console: " + message);
    }
}

public class FileLogger implements Logger {
    @Override
    public void log(String message) {
        // 파일에 로그 기록
    }
}

public class LoggerFactory {
    public static Logger getLogger(String type) {
        return switch (type) {
            case "console" -> new ConsoleLogger();
            case "file" -> new FileLogger();
            default -> throw new IllegalArgumentException("Unknown logger type");
        };
    }
}

```

### 2. 이벤트 처리 시스템

```java
public interface EventListener {
    void onEvent(Event event);
}

public class ButtonClickListener implements EventListener {
    @Override
    public void onEvent(Event event) {
        System.out.println("Button clicked: " + event.getSource());
    }
}

public class MouseMoveListener implements EventListener {
    @Override
    public void onEvent(Event event) {
        System.out.println("Mouse moved to: " + event.getPosition());
    }
}

public class EventManager {
    private List<EventListener> listeners = new ArrayList<>();

    public void addEventListener(EventListener listener) {
        listeners.add(listener);
    }

    public void notify(Event event) {
        listeners.forEach(listener -> listener.onEvent(event));
    }
}

```

### 🚀 추가적인 객체지향 개념

## 4. 추상화 (Abstraction)

### 📌 개념

- 공통적인 특성을 추출하여 상위 개념으로 도출
- 불필요한 세부 사항을 제거하고 핵심적인 개념만 남김

### 💻 예제 코드

```java
// 추상화의 예: 결제 시스템
public sealed interface Payment permits CreditCardPayment, CryptoPayment {
    boolean processPayment(BigDecimal amount);
    PaymentStatus checkStatus();
    record PaymentResult(boolean success, String message) {}
}

public final class CreditCardPayment implements Payment {
    private final String cardNumber;
    private final String expiryDate;
    private final String cvv;

    @Override
    public boolean processPayment(BigDecimal amount) {
        // 신용카드 결제 처리 로직
        return true;
    }

    @Override
    public PaymentStatus checkStatus() {
        // 결제 상태 확인 로직
        return PaymentStatus.COMPLETED;
    }
}

public final class CryptoPayment implements Payment {
    private final String walletAddress;
    private final String cryptoType;

    @Override
    public boolean processPayment(BigDecimal amount) {
        // 암호화폐 결제 처리 로직
        return true;
    }

    @Override
    public PaymentStatus checkStatus() {
        // 블록체인 트랜잭션 상태 확인
        return PaymentStatus.PENDING;
    }
}

```

## 5. 모듈화 (JDK 9+)

### 📌 개념

- 관련된 패키지들을 모듈로 그룹화
- 강력한 캡슐화와 명시적인 의존성 관리

### 💻 예제 코드

```java
// module-info.java
module com.myapp.core {
    requires java.base;
    requires java.sql;

    exports com.myapp.core.api;
    exports com.myapp.core.model to com.myapp.service;

    provides com.myapp.core.spi.ServiceProvider with
        com.myapp.core.impl.ServiceProviderImpl;
}

```

## 6. 레코드 (JDK 16+)

### 📌 개념

- 불변 데이터 객체를 위한 새로운 유형의 클래스
- 자동으로 equals, hashCode, toString 메서드 생성

### 💻 예제 코드

```java
public record PersonRecord(
    String name,
    LocalDate birthDate,
    Address address
) {
    // 컴팩트 생성자
    public PersonRecord {
        Objects.requireNonNull(name, "Name cannot be null");
        Objects.requireNonNull(birthDate, "Birth date cannot be null");
    }

    // 추가 메서드
    public int getAge() {
        return Period.between(birthDate, LocalDate.now()).getYears();
    }

    // 정적 메서드
    public static PersonRecord of(String name, LocalDate birthDate, Address address) {
        return new PersonRecord(name, birthDate, address);
    }
}

```

## 7. 패턴 매칭 (JDK 17)

### 📌 개념

- instanceof 연산자와 함께 사용되는 패턴 매칭
- 타입 확인과 캐스팅을 한 번에 처리

### 💻 예제 코드

```java
public class PatternMatchingExample {
    public static String getDescription(Object obj) {
        return switch (obj) {
            case String s when s.length() > 5 -> "Long string: " + s;
            case String s -> "Short string: " + s;
            case Integer i -> "Number: " + i;
            case PersonRecord p -> "Person: " + p.name();
            case null -> "null value";
            default -> obj.toString();
        };
    }

    public void processShape(Shape shape) {
        if (shape instanceof Rectangle r && r.getWidth() > 100) {
            // 패턴 매칭을 사용한 조건문
            System.out.println("Wide rectangle: " + r.getWidth());
        }
    }
}

```

## 8. 봉인 클래스와 인터페이스 (JDK 17)

### 📌 개념

- 상속 또는 구현이 허용된 클래스를 명시적으로 지정
- 타입 계층 구조의 안전성 향상

### 💻 예제 코드

```java
public sealed interface Vehicle permits Car, Truck, Motorcycle {
    void start();
    void stop();
}

public final class Car implements Vehicle {
    @Override
    public void start() {
        System.out.println("Car starting...");
    }

    @Override
    public void stop() {
        System.out.println("Car stopping...");
    }
}

public non-sealed class Truck implements Vehicle {
    @Override
    public void start() {
        System.out.println("Truck starting...");
    }

    @Override
    public void stop() {
        System.out.println("Truck stopping...");
    }
}

public final class Motorcycle implements Vehicle {
    @Override
    public void start() {
        System.out.println("Motorcycle starting...");
    }

    @Override
    public void stop() {
        System.out.println("Motorcycle stopping...");
    }
}

```

## 🏗️ 클래스와 객체

### 📚 클래스 기본 개념

### ✨ 정의

- 객체를 생성하기 위한 템플릿/설계도
- 객체의 상태(필드)와 행위(메서드)를 정의하는 틀

### 🎯 사용 목적

- 코드의 재사용성 향상
- 데이터 캡슐화 구현
- 객체 지향 프로그래밍의 기본 단위
- 프로그램의 구조화 및 모듈화

### 💡 특징

- 캡슐화: 데이터와 메서드를 하나의 단위로 묶음
- 상속: 기존 클래스의 특성을 새로운 클래스가 물려받음
- 다형성: 같은 타입이지만 다양한 형태의 객체 표현 가능
- 추상화: 공통적인 특성을 추출하여 정의

### 🏗️ 클래스 구조

### 📝 기본 구조

```java
public class ClassName {
    // 1. 필드 선언
    private int instanceField;
    private static int staticField;

    // 2. 생성자
    public ClassName() {
        // 초기화 로직
    }

    // 3. 메서드
    public void instanceMethod() {
        // 인스턴스 메서드 로직
    }

    public static void staticMethod() {
        // 정적 메서드 로직
    }
}

```

### 🔒 접근 제어자

| 제어자 | 같은 클래스 | 같은 패키지 | 자식 클래스 | 전체 |
| --- | --- | --- | --- | --- |
| private | O | X | X | X |
| default | O | O | X | X |
| protected | O | O | O | X |
| public | O | O | O | O |

### 🎨 클래스 구성 요소

### 3.1 📦 필드 (Fields)

### 📌 특징

- 객체의 상태를 저장
- 데이터의 무결성 보장
- 접근 제어를 통한 캡슐화

### 🔍 종류

1. **인스턴스 필드**
    - 각 객체마다 독립적인 값 보유
    - 객체 생성 시 메모리 할당
2. **정적 필드**
    - 클래스당 하나의 값만 존재
    - 모든 인스턴스가 공유
3. **상수**
    - 변경 불가능한 값
    - static final로 선언

### 💻 예제 코드

```java
public class Student {
    // 인스턴스 필드
    private String name;
    private int studentId;
    private List<Integer> grades;

    // 정적 필드
    private static int totalStudents = 0;

    // 상수
    public static final int MAX_GRADE = 100;
    private static final double PASSING_SCORE = 60.0;

    // 열거형 상수
    public enum Status {
        ACTIVE, INACTIVE, GRADUATED
    }
    private Status status;

    // 컬렉션 필드
    private Map<String, Integer> courseScores = new HashMap<>();
    private Set<String> completedCourses = new HashSet<>();
}

```

### 3.2 🏗️ 생성자 (Constructors)

### 📌 특징

- 객체 생성 시 초기화 담당
- 클래스명과 동일한 이름
- 반환 타입이 없음
- 오버로딩 가능

### 🔍 종류

1. **기본 생성자**
    - 매개변수가 없는 생성자
    - 클래스에 생성자가 없으면 자동 생성
2. **매개변수 생성자**
    - 특정 값으로 초기화하는 생성자
    - 객체 생성 시 초기값 설정
3. **복사 생성자**
    - 기존 객체를 복사하여 새 객체 생성
4. **정적 팩토리 메서드**
    - 생성자 대신 사용하는 객체 생성 메서드

### 💻 예제 코드

```java
public class BankAccount {
    private String accountNumber;
    private double balance;
    private String ownerName;
    private AccountType type;

    // 1. 기본 생성자
    public BankAccount() {
        this("", 0.0, "Unknown", AccountType.SAVINGS);
    }

    // 2. 매개변수 생성자
    public BankAccount(String accountNumber, double balance,
                      String ownerName, AccountType type) {
        validateAccountNumber(accountNumber);
        validateInitialBalance(balance);

        this.accountNumber = accountNumber;
        this.balance = balance;
        this.ownerName = ownerName;
        this.type = type;
    }

    // 3. 복사 생성자
    public BankAccount(BankAccount other) {
        this(other.accountNumber, other.balance,
             other.ownerName, other.type);
    }

    // 4. 정적 팩토리 메서드
    public static BankAccount createSavingsAccount(String ownerName) {
        return new BankAccount(generateAccountNumber(),
                             0.0, ownerName, AccountType.SAVINGS);
    }

    // 유효성 검사 메서드
    private void validateAccountNumber(String accountNumber) {
        if (accountNumber == null || accountNumber.trim().isEmpty()) {
            throw new IllegalArgumentException("Account number cannot be empty");
        }
    }

    private void validateInitialBalance(double balance) {
        if (balance < 0) {
            throw new IllegalArgumentException("Initial balance cannot be negative");
        }
    }

    private static String generateAccountNumber() {
        return "ACC" + UUID.randomUUID().toString().substring(0, 8);
    }
}

```

### 3.3 🛠️ 메서드 (Methods)

### 📌 특징

- 객체의 행위를 정의
- 코드 재사용성 증가
- 객체 간 통신 수단
- 캡슐화된 데이터 접근 방법

### 🔍 종류

1. **인스턴스 메서드**
    - 객체의 상태를 변경하거나 조회
    - this 키워드로 인스턴스 접근
2. **정적 메서드**
    - 클래스 레벨의 기능
    - 인스턴스 없이 호출 가능
3. **접근자/수정자 메서드**
    - getter/setter
    - 캡슐화 구현
4. **유틸리티 메서드**
    - 공통 기능 제공
    - 주로 static으로 선언

### 💻 예제 코드

```java
public class ShoppingCart {
    private List<Item> items = new ArrayList<>();
    private double totalPrice;
    private static final double TAX_RATE = 0.1;

    // 1. 인스턴스 메서드
    public void addItem(Item item) {
        validateItem(item);
        items.add(item);
        calculateTotal();
    }

    public void removeItem(Item item) {
        items.remove(item);
        calculateTotal();
    }

    // 2. 정적 메서드
    public static double calculateTax(double amount) {
        return amount * TAX_RATE;
    }

    // 3. 접근자/수정자 메서드
    public List<Item> getItems() {
        return new ArrayList<>(items);  // 방어적 복사
    }

    public double getTotalPrice() {
        return totalPrice;
    }

    // 4. 유틸리티 메서드
    private void calculateTotal() {
        totalPrice = items.stream()
                         .mapToDouble(Item::getPrice)
                         .sum();
        totalPrice += calculateTax(totalPrice);
    }

    // 5. 비즈니스 로직 메서드
    public void checkout() {
        validateCart();
        processPayment();
        clearCart();
        notifyCustomer();
    }

    // 6. 검증 메서드
    private void validateItem(Item item) {
        if (item == null) {
            throw new IllegalArgumentException("Item cannot be null");
        }
        if (item.getPrice() < 0) {
            throw new IllegalArgumentException("Item price cannot be negative");
        }
    }

    private void validateCart() {
        if (items.isEmpty()) {
            throw new IllegalStateException("Cart is empty");
        }
    }
}

```

### 🚀 고급 기능

### 4.1 중첩 클래스

- 클래스 내부에 선언된 클래스
- 코드의 캡슐화 강화
- 관련 클래스들의 논리적 그룹화

```java
public class EmailService {
    // 정적 중첩 클래스
    public static class EmailBuilder {
        private String to;
        private String subject;
        private String content;

        public EmailBuilder to(String to) {
            this.to = to;
            return this;
        }

        public Email build() {
            return new Email(to, subject, content);
        }
    }

    // 내부 클래스
    private class EmailValidator {
        boolean isValid(String email) {
            return email != null && email.contains("@");
        }
    }
}

```

### 4.2 제네릭 클래스

- 타입 안정성 보장
- 코드 재사용성 향상
- 컴파일 시점 타입 체크

```java
public class DataContainer<T> {
    private T data;
    private List<T> history = new ArrayList<>();

    public void setData(T data) {
        history.add(this.data);
        this.data = data;
    }

    public T getData() {
        return data;
    }

    public List<T> getHistory() {
        return new ArrayList<>(history);
    }
}

```

### ⚠️ 주의 사항

### 5.1 메모리 관리

- 순환 참조 피하기
- 리소스 적절히 해제
- 메모리 누수 방지

### 5.2 스레드 안전성

- 공유 리소스 동기화
- 불변 객체 사용 권장
- 동시성 고려

### 5.3 성능 최적화

- 불필요한 객체 생성 피하기
- 적절한 캐싱 전략
- 효율적인 알고리즘 사용

### 📚 응용 예제

### 6.1 이벤트 시스템

```java
public class EventManager {
    private Map<String, List<EventListener>> listeners = new HashMap<>();

    public void subscribe(String eventType, EventListener listener) {
        listeners.computeIfAbsent(eventType, k -> new ArrayList<>())
                .add(listener);
    }

    public void notify(String eventType, String data) {
        List<EventListener> eventListeners = listeners.get(eventType);
        if (eventListeners != null) {
            eventListeners.forEach(listener -> listener.update(data));
        }
    }
}

```

### 6.2 캐시 시스템

```java
public class Cache<K, V> {
    private final Map<K, CacheEntry<V>> cache = new ConcurrentHashMap<>();
    private final long expirationTimeInMillis;

    public Cache(long expirationTimeInMillis) {
        this.expirationTimeInMillis = expirationTimeInMillis;
    }

    public void put(K key, V value) {
        cache.put(key, new CacheEntry<>(value, System.currentTimeMillis()));
    }

    public Optional<V> get(K key) {
        CacheEntry<V> entry = cache.get(key);
        if (entry != null && !isExpired(entry)) {
            return Optional.of(entry.value());
        }
        cache.remove(key);
        return Optional.empty();
    }

    private boolean isExpired(CacheEntry<V> entry) {
        return System.currentTimeMillis() - entry.timestamp() > expirationTimeInMillis;
    }

    private record CacheEntry<V>(V value, long timestamp) {}
}

```

## 🆕 새로운 기능들

### 📋 레코드 (Record) - JDK 16

### 목적

- 불변 데이터 객체를 간단히 생성
- DTO(Data Transfer Object) 작성 간소화

### 특징

- 자동 생성: 생성자, getter, equals, hashCode, toString
- final 클래스 (상속 불가)
- 불변(immutable) 객체

### 예제

```java
public record Person(String name, int age) {
    // 컴팩트 생성자
    public Person {
        if (age < 0) {
            throw new IllegalArgumentException("나이는 음수일 수 없습니다.");
        }
    }

    // 추가 메소드
    public boolean isAdult() {
        return age >= 18;
    }
}

// 사용
Person person = new Person("John", 25);
System.out.println(person.name()); // getter 호출
System.out.println(person.isAdult()); // 메소드 호출

```

### 🔒 봉인 클래스 (Sealed Classes) - JDK 17

### 목적

- 상속 가능한 클래스를 제한
- 계층 구조의 엄격한 제어

### 특징

- permits 키워드로 허용할 하위 클래스 지정
- 하위 클래스는 final, sealed, non-sealed 중 하나여야 함

### 예제

```java
public sealed class Shape
    permits Circle, Rectangle, Triangle {
    // 클래스 내용
}

public final class Circle extends Shape {
    private double radius;

    public double getArea() {
        return Math.PI * radius * radius;
    }
}

public sealed class Rectangle extends Shape
    permits Square {
    // Rectangle 구현
}

public final class Square extends Rectangle {
    // Square 구현
}

```

### 🎯 패턴 매칭 - JDK 17

### 목적

- 타입 검사와 캐스팅을 한 번에 처리
- 코드 간소화 및 가독성 향상

### 예제

```java
// instanceof 패턴 매칭
if (obj instanceof String str && str.length() > 5) {
    System.out.println(str.toUpperCase());
}

// switch 패턴 매칭 (Preview)
String formatted = switch (obj) {
    case Integer i -> String.format("int %d", i);
    case Long l    -> String.format("long %d", l);
    case Double d  -> String.format("double %f", d);
    case String s  -> String.format("String %s", s);
    default        -> obj.toString();
};

```

### 🔄 향상된 switch 표현식 - JDK 14

### 특징

- 화살표 구문 지원
- 다중 레이블 case 지원
- yield 키워드로 값 반환

### 예제

```java
public enum Day { MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY }

String result = switch (day) {
    case MONDAY, FRIDAY -> "주말 근처";
    case TUESDAY -> "화요일";
    case WEDNESDAY, THURSDAY -> {
        System.out.println("주중입니다.");
        yield "평일";
    }
    default -> "알 수 없는 요일";
};

```

## 🎯 객체지향 설계 원칙 (SOLID)

### 📌 단일 책임 원칙 (SRP)

### 개념

- 한 클래스는 하나의 책임만 가져야 함
- 변경의 이유가 하나여야 함

### 원칙의 세부 규칙

1. **책임의 정의**
    - 변경을 위한 하나의 이유만 존재해야 함
    - 클래스는 하나의 액터(사용자/이해관계자)에 대해서만 책임져야 함
2. **응집도**
    - 클래스의 모든 멤버가 해당 클래스의 목적을 위해 협력
    - 관련 없는 기능은 다른 클래스로 분리
3. **책임의 분배**
    - 각 책임은 명확하게 분리되어야 함
    - 다른 책임과의 결합도를 최소화

### SRP 준수의 이점

1. **유지보수성 향상**
    - 코드 변경 시 영향 범위가 제한적
    - 버그 발생 가능성 감소
2. **테스트 용이성**
    - 작은 단위의 테스트 가능
    - 명확한 책임으로 테스트 케이스 작성 용이
3. **재사용성 증가**
    - 작은 단위의 클래스로 조합 가능
    - 특정 기능만 필요할 때 해당 클래스만 사용

### 예제 설명

```java
// 잘못된 예 - 여러 책임이 혼재
class UserService {
    void saveUser() { /* 사용자 저장 로직 */ }
    void sendEmail() { /* 이메일 발송 로직 */ }
    void generateReport() { /* 리포트 생성 로직 */ }
}

// 올바른 예 - 책임별로 분리
class UserService {
    private final UserRepository userRepository;

    void saveUser(User user) {
        userRepository.save(user);
    }
}

class EmailService {
    private final EmailSender emailSender;

    void sendEmail(String to, String content) {
        emailSender.send(to, content);
    }
}

class ReportService {
    private final ReportGenerator reportGenerator;

    void generateReport(ReportType type) {
        reportGenerator.generate(type);
    }
}

```

### 🔓 개방-폐쇄 원칙 (OCP)

### 개념

- 확장에는 열려있고, 수정에는 닫혀있어야 함
- 기존 코드 변경 없이 새로운 기능 추가 가능

### 원칙의 세부 규칙

1. **추상화와 다형성**
    - 인터페이스나 추상 클래스를 통한 확장 지점 제공
    - 구체적인 구현은 추상화를 통해 확장
2. **변경의 영향 범위**
    - 새로운 기능 추가가 기존 코드에 영향을 주지 않아야 함
    - 기존 클래스의 수정 없이 동작 변경 가능
3. **설계 방식**
    - 변경이 예상되는 부분을 추상화
    - 구체적인 구현은 별도의 클래스로 분리

### OCP 준수의 이점

1. **확장성 향상**
    - 새로운 기능 추가가 용이
    - 기존 코드의 안정성 보장
2. **재사용성 증가**
    - 기존 코드를 그대로 활용
    - 새로운 맥락에서도 사용 가능
3. **유지보수성 개선**
    - 기존 코드 수정 위험 감소
    - 테스트 용이성 향상

### 예제 설명

```java
// 결제 처리 인터페이스
interface PaymentProcessor {
    void processPayment(Payment payment);
}

// 구체적인 결제 처리 구현
class CreditCardProcessor implements PaymentProcessor {
    @Override
    public void processPayment(Payment payment) {
        // 신용카드 결제 처리 로직
        validateCard(payment);
        processTransaction(payment);
        sendReceipt(payment);
    }
}

class PayPalProcessor implements PaymentProcessor {
    @Override
    public void processPayment(Payment payment) {
        // PayPal 결제 처리 로직
        authenticatePayPal(payment);
        executePayment(payment);
        notifyUser(payment);
    }
}

// 새로운 결제 방식 추가 - 기존 코드 수정 없음
class CryptoProcessor implements PaymentProcessor {
    @Override
    public void processPayment(Payment payment) {
        // 암호화폐 결제 처리 로직
        verifyWallet(payment);
        transferCrypto(payment);
        confirmTransaction(payment);
    }
}

// 결제 서비스 - 구체적인 구현에 의존하지 않음
class PaymentService {
    private final PaymentProcessor processor;

    public PaymentService(PaymentProcessor processor) {
        this.processor = processor;
    }

    public void processPayment(Payment payment) {
        processor.processPayment(payment);
    }
}

```

### 🔄 리스코프 치환 원칙 (LSP)

### 개념

- 하위 타입은 상위 타입을 대체할 수 있어야 함
- 프로그램의 정확성을 깨뜨리지 않으면서 상위 타입의 객체를 하위 타입의 객체로 치환할 수 있어야 함
- 상속 관계가 올바르게 설계되었는지 판단하는 기준

### 원칙의 세부 규칙

1. **선행 조건(precondition)**
    - 하위 타입의 메서드는 상위 타입의 메서드보다 더 약한 선행 조건을 가져야 함
2. **후행 조건(postcondition)**
    - 하위 타입의 메서드는 상위 타입의 메서드보다 더 강한 후행 조건을 가져야 함
3. **불변식(invariant)**
    - 하위 타입은 상위 타입의 불변식을 유지해야 함

### 위반 사례

- 상위 타입의 메서드가 명세된 동작을 하위 타입이 위반하는 경우
- 상위 타입에서 정의한 반환 값의 범위를 하위 타입이 벗어나는 경우
- 상위 타입에서 발생하지 않는 예외를 하위 타입에서 발생시키는 경우

### LSP 준수의 이점

1. **코드의 유연성 향상**
    - 상위 타입으로 프로그래밍할 수 있어 다형성을 효과적으로 활용 가능
2. **재사용성 증가**
    - 상위 타입을 사용하는 코드를 수정하지 않고도 새로운 하위 타입 추가 가능
3. **테스트 용이성**
    - 상위 타입의 테스트가 하위 타입에도 적용 가능
4. **유지보수성 향상**
    - 코드 변경 시 영향 범위를 예측하기 쉬움

### 예제

```java
// 잘못된 예
class Bird {
    void fly() {
        // 날기 구현
    }
}

class Penguin extends Bird { // LSP 위반
    @Override
    void fly() {
        throw new UnsupportedOperationException("펭귄은 날 수 없습니다.");
    }
}

// 올바른 예
interface Flyable {
    void fly();
}

class Bird {
    // 모든 새의 공통 특성
    void eat() { }
    void sleep() { }
}

class Sparrow extends Bird implements Flyable {
    public void fly() {
        // 참새의 비행 구현
    }
}

class Penguin extends Bird {
    // 날지 않는 새
}

```

### 🔍 인터페이스 분리 원칙 (ISP)

### 개념

- 클라이언트는 자신이 사용하지 않는 메소드에 의존하면 안 됨
- 하나의 일반적인 인터페이스보다 여러 개의 구체적인 인터페이스가 낫다

### 원칙의 세부 규칙

1. **인터페이스 분리**
    - 큰 인터페이스를 구체적이고 작은 단위로 분리
    - 클라이언트의 필요에 따라 인터페이스를 분리
2. **단일 책임**
    - 각 인터페이스는 특정 클라이언트를 위한 하나의 책임만을 가져야 함
    - 변경의 이유가 하나여야 함
3. **인터페이스 응집도**
    - 관련된 메서드들을 하나의 인터페이스로 모음
    - 서로 무관한 메서드들은 별도의 인터페이스로 분리

### ISP 준수의 이점

1. **유지보수성 향상**
    - 인터페이스 변경이 다른 클라이언트에 영향을 미치지 않음
2. **재사용성 증가**
    - 필요한 기능만 구현하여 사용 가능
3. **의존성 감소**
    - 불필요한 의존성을 제거하여 시스템 결합도 감소

### 예제

```java
// 잘못된 예
interface Worker {
    void work();
    void eat();
    void sleep();
}

// 올바른 예
interface Workable {
    void work();
}

interface Eatable {
    void eat();
}

interface Sleepable {
    void sleep();
}

class Human implements Workable, Eatable, Sleepable {
    @Override
    public void work() { /* 일하기 구현 */ }

    @Override
    public void eat() { /* 먹기 구현 */ }

    @Override
    public void sleep() { /* 잠자기 구현 */ }
}

class Robot implements Workable {
    @Override
    public void work() { /* 일하기 구현 */ }
    // 로봇은 먹거나 자지 않으므로 해당 인터페이스를 구현하지 않음
}

```

### 🔄 의존성 역전 원칙 (DIP)

### 개념

- 고수준 모듈은 저수준 모듈에 의존하면 안 됨
- 둘 다 추상화에 의존해야 함
- 추상화는 세부 사항에 의존하지 않아야 함

### 원칙의 핵심 요소

1. **고수준 모듈**
    - 비즈니스 규칙이나 로직을 포함
    - 다른 모듈을 사용하는 모듈
2. **저수준 모듈**
    - 세부적인 구현을 담당
    - 기본적인 작업을 수행하는 모듈
3. **추상화**
    - 인터페이스나 추상 클래스를 통한 의존성 분리
    - 구현 세부사항으로부터 독립적

### DIP 준수의 이점

1. **유연성 증가**
    - 구현체를 쉽게 교체 가능
    - 테스트와 목업이 용이
2. **재사용성 향상**
    - 모듈간 결합도 감소
    - 독립적인 배포와 개발 가능
3. **확장성 개선**
    - 새로운 구현체 추가가 용이
    - 기존 코드 수정 최소화

### 예제

```java
// 잘못된 예
class EmailService {
    void sendEmail(String message) {
        // 이메일 전송 로직
    }
}

class OrderService {
    private EmailService emailService = new EmailService(); // 구체 클래스에 직접 의존

    void processOrder() {
        // 주문 처리
        emailService.sendEmail("주문이 처리되었습니다.");
    }
}

// 올바른 예
interface MessageService {
    void sendMessage(String message);
}

class EmailService implements MessageService {
    @Override
    public void sendMessage(String message) {
        // 이메일 전송 로직
    }
}

class SMSService implements MessageService {
    @Override
    public void sendMessage(String message) {
        // SMS 전송 로직
    }
}

class OrderService {
    private final MessageService messageService; // 추상화에 의존

    public OrderService(MessageService messageService) {
        this.messageService = messageService;
    }

    void processOrder() {
        // 주문 처리
        messageService.sendMessage("주문이 처리되었습니다.");
    }
}

```

## 🎨 디자인 패턴

### 🏗️ 빌더 패턴

### 목적

- 복잡한 객체의 생성 과정과 표현 방법을 분리
- 동일한 생성 절차로 서로 다른 표현 결과를 만들 수 있게 함

### 예제

```java
public class Person {
    private final String firstName;
    private final String lastName;
    private final int age;
    private final String address;
    private final String phone;

    private Person(Builder builder) {
        this.firstName = builder.firstName;
        this.lastName = builder.lastName;
        this.age = builder.age;
        this.address = builder.address;
        this.phone = builder.phone;
    }

    public static class Builder {
        private String firstName;
        private String lastName;
        private int age;
        private String address;
        private String phone;

        public Builder firstName(String firstName) {
            this.firstName = firstName;
            return this;
        }

        public Builder lastName(String lastName) {
            this.lastName = lastName;
            return this;
        }

        public Builder age(int age) {
            this.age = age;
            return this;
        }

        public Builder address(String address) {
            this.address = address;
            return this;
        }

        public Builder phone(String phone) {
            this.phone = phone;
            return this;
        }

        public Person build() {
            return new Person(this);
        }
    }
}

// 사용 예
Person person = new Person.Builder()
    .firstName("John")
    .lastName("Doe")
    .age(30)
    .address("123 Street")
    .phone("123-456-7890")
    .build();

```

### 🔄 싱글톤 패턴

### 목적

- 클래스의 인스턴스가 하나만 생성되도록 보장
- 전역적인 접근점 제공

### 구현 방법

```java
// 1. 기본 싱글톤
public class Singleton {
    private static Singleton instance;

    private Singleton() {}

    public static synchronized Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}

// 2. Double-Checked Locking
public class Singleton {
    private static volatile Singleton instance;

    private Singleton() {}

    public static Singleton getInstance() {
        if (instance == null) {
            synchronized (Singleton.class) {
                if (instance == null) {
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}

// 3. 초기화 지연 홀더 클래스
public class Singleton {
    private Singleton() {}

    private static class SingletonHolder {
        private static final Singleton INSTANCE = new Singleton();
    }

    public static Singleton getInstance() {
        return SingletonHolder.INSTANCE;
    }
}

```

### 🏭 팩토리 메소드 패턴

### 목적

- 객체 생성을 서브클래스에 위임
- 객체 생성 로직을 캡슐화

### 예제

```java
// 제품 인터페이스
interface Animal {
    void makeSound();
}

// 구체적인 제품
class Dog implements Animal {
    @Override
    public void makeSound() {
        System.out.println("멍멍!");
    }
}

class Cat implements Animal {
    @Override
    public void makeSound() {
        System.out.println("야옹!");
    }
}

// 팩토리 클래스
class AnimalFactory {
    public Animal createAnimal(String type) {
        switch (type.toLowerCase()) {
            case "dog":
                return new Dog();
            case "cat":
                return new Cat();
            default:
                throw new IllegalArgumentException("Unknown animal type");
        }
    }
}

// 사용 예
AnimalFactory factory = new AnimalFactory();
Animal dog = factory.createAnimal("dog");
dog.makeSound(); // 출력: 멍멍!

```
